var tipuesearch = {"pages":[{"title":" Matcha ","text":"Matcha","tags":"home","loc":"index.html"},{"title":"distribution_t – Matcha ","text":"type, public :: distribution_t Components Type Visibility Attributes Name Initial double precision, private, allocatable, dimension(:) :: vel_ double precision, private, allocatable, dimension(:) :: cumulative_distribution_ Constructor public        interface distribution_t private pure module function construct(sample_distribution) result(distribution) Implementation → Arguments Type Intent Optional Attributes Name double precision, intent(in) :: sample_distribution (:,:) Return Value type( distribution_t ) Type-Bound Procedures procedure, public :: cumulative_distribution interface private pure module function cumulative_distribution(self) result(my_cumulative_distribution) Implementation → Arguments Type Intent Optional Attributes Name class( distribution_t ), intent(in) :: self Return Value double precision, allocatable, (:) procedure, public :: velocities interface private pure module function velocities(self, speeds, directions) result(my_velocities) Implementation → Return the t_cell_collection_t object's velocity vectors Arguments Type Intent Optional Attributes Name class( distribution_t ), intent(in) :: self double precision, intent(in) :: speeds (:,:) double precision, intent(in) :: directions (:,:,:) Return Value double precision, allocatable, (:,:,:)","tags":"","loc":"type/distribution_t.html"},{"title":"t_cell_collection_t – Matcha ","text":"type, public :: t_cell_collection_t Encapsulate the state of a collection of T cells Inherited by type~~t_cell_collection_t~~InheritedByGraph type~t_cell_collection_t t_cell_collection_t type~output_t output_t type~output_t->type~t_cell_collection_t history_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial double precision, private, allocatable :: positions_ (:,:) position vectors double precision, private :: time_ time stamp Constructor public        interface t_cell_collection_t private pure module function construct(positions, time) result(t_cell_collection) Implementation → Return a t_cell_collection_t object with rescaled position vectors and the provided time stamp Arguments Type Intent Optional Attributes Name double precision, intent(in) :: positions (:,:) double precision, intent(in) :: time Return Value type( t_cell_collection_t ) Type-Bound Procedures procedure, public :: positions interface private pure module function positions(self) result(my_positions) Implementation → Return the t_cell_collection_t object's position vectors Arguments Type Intent Optional Attributes Name class( t_cell_collection_t ), intent(in) :: self Return Value double precision, allocatable, (:,:) procedure, public :: time interface private elemental module function time(self) result(my_time) Implementation → Return the t_cell_collection_t object's time stamp Arguments Type Intent Optional Attributes Name class( t_cell_collection_t ), intent(in) :: self Return Value double precision","tags":"","loc":"type/t_cell_collection_t.html"},{"title":"t_cell_collection_bind_C_t – Matcha ","text":"type, public, bind(C) :: t_cell_collection_bind_C_t Inherits type~~t_cell_collection_bind_c_t~~InheritsGraph type~t_cell_collection_bind_c_t t_cell_collection_bind_C_t c_ptr c_ptr type~t_cell_collection_bind_c_t->c_ptr positions_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type(c_ptr), public :: positions_ptr integer(kind=c_int), public :: positions_shape (positions_dimension) real(kind=c_double), public :: time Constructor public        interface t_cell_collection_bind_C_t private elemental module function construct_bind_C(t_cell_collection) result(t_cell_collection_bind_C) Implementation → Result is bind(C) representation of the data inside a t_cell_collection_t object Arguments Type Intent Optional Attributes Name type( t_cell_collection_t ), intent(in), target :: t_cell_collection Return Value type( t_cell_collection_bind_C_t )","tags":"","loc":"type/t_cell_collection_bind_c_t.html"},{"title":"output_t – Matcha ","text":"type, public :: output_t Encapsulate an input/result pair Inherits type~~output_t~~InheritsGraph type~output_t output_t type~input_t input_t type~output_t->type~input_t input_ type~t_cell_collection_t t_cell_collection_t type~output_t->type~t_cell_collection_t history_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( input_t ), private :: input_ type( t_cell_collection_t ), private, allocatable :: history_ (:) Constructor public        interface output_t private pure module function construct(input, history) result(output) Implementation → Construct a new output_t object Arguments Type Intent Optional Attributes Name type( input_t ), intent(in) :: input type( t_cell_collection_t ), intent(in) :: history (:) Return Value type( output_t ) Type-Bound Procedures procedure, public :: simulated_distribution interface private module function simulated_distribution(self) result(output_distribution) Implementation → The result is a histogram calculated from the simulation output Arguments Type Intent Optional Attributes Name class( output_t ), intent(in) :: self Return Value double precision, allocatable, (:,:) procedure, public :: my_num_cells interface private pure module function my_num_cells(self) result(num_cells) Implementation → Arguments Type Intent Optional Attributes Name class( output_t ), intent(in) :: self Return Value integer","tags":"","loc":"type/output_t.html"},{"title":"subdomain_t – Matcha ","text":"type, public :: subdomain_t Components Type Visibility Attributes Name Initial real, private, allocatable :: s_ (:,:,:) Type-Bound Procedures procedure, public, pass(self) :: define interface private module subroutine define(side, boundary_val, internal_val, n, self) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in) :: side real, intent(in) :: boundary_val real, intent(in) :: internal_val integer, intent(in) :: n number of grid points in each coordinate direction class( subdomain_t ), intent(out) :: self procedure, public, pass(self) :: step interface private module subroutine step(alpha_dt, self) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in) :: alpha_dt class( subdomain_t ), intent(inout) :: self procedure, public, pass(rhs) :: multiply interface private pure module function multiply(lhs, rhs) result(product) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in) :: lhs class( subdomain_t ), intent(in) :: rhs Return Value type( subdomain_t ) generic, public :: operator(.laplacian.) => laplacian private  interface laplacian () Arguments None generic, public :: operator(*) => multiply private  interface multiply () Arguments None generic, public :: operator(+) => add private  interface add () Arguments None generic, public :: assignment(=) => assign_and_sync private  interface assign_and_sync () Arguments None procedure, public :: dt_stable interface private pure module function dt_stable(self, alpha) result(my_dt) Implementation → Set the time step at 90% of the stability limit obtained generalizing to 3D the value provided for 2D by\nKassinos, S., & Alexiadis, A. (2024). Beyond Language: Applying MLX Transformers to Engineering Physics. \narXiv preprint arXiv:2410.04167. Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self real, intent(in) :: alpha Return Value real procedure, public :: dx interface private pure module function dx(self) result(my_dx) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real procedure, public :: dy interface private pure module function dy(self) result(my_dy) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real procedure, public :: dz interface private pure module function dz(self) result(my_dz) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real procedure, public :: values interface private pure module function values(self) result(my_values) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real, allocatable, (:,:,:) procedure, private :: laplacian interface private pure module function laplacian(rhs) result(laplacian_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: rhs Return Value type( subdomain_t ) procedure, private :: add interface private pure module function add(lhs, rhs) result(total) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: lhs type( subdomain_t ), intent(in) :: rhs Return Value type( subdomain_t ) procedure, private :: assign_and_sync interface private module subroutine assign_and_sync(lhs, rhs) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(out) :: lhs type( subdomain_t ), intent(in) :: rhs","tags":"","loc":"type/subdomain_t.html"},{"title":"input_t – Matcha ","text":"type, public :: input_t Inherited by type~~input_t~~InheritedByGraph type~input_t input_t type~output_t output_t type~output_t->type~input_t input_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer, private :: num_cells_ = 6000 integer, private :: num_positions_ = 6000 integer, private :: num_dimensions_ = 3 integer, private :: num_intervals_ = 4 double precision, private :: time_step_ = 0.1D0 Type-Bound Procedures procedure, public :: num_cells interface private pure module function num_cells(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer procedure, public :: num_positions interface private pure module function num_positions(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer procedure, public :: num_dimensions interface private pure module function num_dimensions(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer procedure, public :: num_intervals interface private pure module function num_intervals(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer procedure, public :: time_step interface private pure module function time_step(self) result(dt) Implementation → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value double precision procedure, public :: sample_distribution interface private pure module function sample_distribution(self) result(empirical_distribution) Implementation → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value double precision, allocatable, (:,:)","tags":"","loc":"type/input_t.html"},{"title":"distribution_t – Matcha","text":"public interface distribution_t Functions private pure module function construct(sample_distribution) result(distribution) Implementation → Arguments Type Intent Optional Attributes Name double precision, intent(in) :: sample_distribution (:,:) Return Value type( distribution_t )","tags":"","loc":"interface/distribution_t.html"},{"title":"cumulative_distribution – Matcha","text":"interface Called by interface~~cumulative_distribution~~CalledByGraph interface~cumulative_distribution distribution_t%cumulative_distribution proc~velocities velocities proc~velocities->interface~cumulative_distribution Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private pure module function cumulative_distribution(self) result(my_cumulative_distribution) Implementation → Arguments Type Intent Optional Attributes Name class( distribution_t ), intent(in) :: self Return Value double precision,allocatable,(:)","tags":"","loc":"interface/cumulative_distribution.html"},{"title":"velocities – Matcha","text":"interface private pure module function velocities(self, speeds, directions) result(my_velocities) Implementation → Arguments Type Intent Optional Attributes Name class( distribution_t ), intent(in) :: self double precision, intent(in) :: speeds (:,:) double precision, intent(in) :: directions (:,:,:) Return Value double precision,allocatable,(:,:,:) Description Return the t_cell_collection_t object's velocity vectors","tags":"","loc":"interface/velocities.html"},{"title":"t_cell_collection_t – Matcha","text":"public interface t_cell_collection_t Functions private pure module function construct(positions, time) result(t_cell_collection) Implementation → Return a t_cell_collection_t object with rescaled position vectors and the provided time stamp Arguments Type Intent Optional Attributes Name double precision, intent(in) :: positions (:,:) double precision, intent(in) :: time Return Value type( t_cell_collection_t )","tags":"","loc":"interface/t_cell_collection_t.html"},{"title":"t_cell_collection_bind_C_t – Matcha","text":"public interface t_cell_collection_bind_C_t Functions private elemental module function construct_bind_C(t_cell_collection) result(t_cell_collection_bind_C) Implementation → Result is bind(C) representation of the data inside a t_cell_collection_t object Arguments Type Intent Optional Attributes Name type( t_cell_collection_t ), intent(in), target :: t_cell_collection Return Value type( t_cell_collection_bind_C_t )","tags":"","loc":"interface/t_cell_collection_bind_c_t.html"},{"title":"positions – Matcha","text":"interface Called by interface~~positions~~CalledByGraph interface~positions t_cell_collection_t%positions proc~matcha matcha proc~matcha->interface~positions proc~my_num_cells my_num_cells proc~my_num_cells->interface~positions Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private pure module function positions(self) result(my_positions) Implementation → Arguments Type Intent Optional Attributes Name class( t_cell_collection_t ), intent(in) :: self Return Value double precision,allocatable,(:,:) Description Return the t_cell_collection_t object's position vectors","tags":"","loc":"interface/positions.html"},{"title":"time – Matcha","text":"interface private elemental module function time(self) result(my_time) Implementation → Arguments Type Intent Optional Attributes Name class( t_cell_collection_t ), intent(in) :: self Return Value double precision Description Return the t_cell_collection_t object's time stamp","tags":"","loc":"interface/time.html"},{"title":"matcha – Matcha","text":"interface Called by interface~~matcha~~CalledByGraph interface~matcha matcha program~main main program~main->interface~matcha Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public module function matcha(input) result(history) Implementation → Arguments Type Intent Optional Attributes Name type( input_t ), intent(in) :: input Return Value type( t_cell_collection_t ),allocatable,(:)","tags":"","loc":"interface/matcha.html"},{"title":"monotonically_increasing – Matcha","text":"pure function monotonically_increasing(f) result(monotonic) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: f (:) Return Value logical Called by proc~~monotonically_increasing~~CalledByGraph proc~monotonically_increasing monotonically_increasing proc~construct~2 construct proc~construct~2->proc~monotonically_increasing Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/monotonically_increasing.html"},{"title":"do_concurrent_sampled_speeds – Matcha","text":"interface Called by interface~~do_concurrent_sampled_speeds~~CalledByGraph interface~do_concurrent_sampled_speeds do_concurrent_sampled_speeds proc~velocities velocities proc~velocities->interface~do_concurrent_sampled_speeds Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public pure module subroutine do_concurrent_sampled_speeds(speeds, vel, cumulative_distribution, sampled_speeds) bind(C) Implementation → Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: speeds (:,:) real(kind=c_double), intent(in) :: vel (:) real(kind=c_double), intent(in) :: cumulative_distribution (:) real(kind=c_double), intent(out), allocatable :: sampled_speeds (:,:)","tags":"","loc":"interface/do_concurrent_sampled_speeds.html"},{"title":"do_concurrent_my_velocities – Matcha","text":"interface Called by interface~~do_concurrent_my_velocities~~CalledByGraph interface~do_concurrent_my_velocities do_concurrent_my_velocities proc~velocities velocities proc~velocities->interface~do_concurrent_my_velocities Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public pure module subroutine do_concurrent_my_velocities(nsteps, dir, sampled_speeds, my_velocities) bind(C) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: nsteps real(kind=c_double), intent(in) :: dir (:,:,:) real(kind=c_double), intent(in) :: sampled_speeds (:,:) real(kind=c_double), intent(out), allocatable :: my_velocities (:,:,:)","tags":"","loc":"interface/do_concurrent_my_velocities.html"},{"title":"do_concurrent_k – Matcha","text":"interface Called by interface~~do_concurrent_k~~CalledByGraph interface~do_concurrent_k do_concurrent_k proc~simulated_distribution simulated_distribution proc~simulated_distribution->interface~do_concurrent_k Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public pure module subroutine do_concurrent_k(speeds, vel, k) bind(C) Implementation → Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: speeds (:) real(kind=c_double), intent(in) :: vel (:) integer(kind=c_int), intent(out), allocatable :: k (:)","tags":"","loc":"interface/do_concurrent_k.html"},{"title":"do_concurrent_output_distribution – Matcha","text":"interface Called by interface~~do_concurrent_output_distribution~~CalledByGraph interface~do_concurrent_output_distribution do_concurrent_output_distribution proc~simulated_distribution simulated_distribution proc~simulated_distribution->interface~do_concurrent_output_distribution Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public pure module subroutine do_concurrent_output_distribution(nintervals, speed, freq, emp_distribution, k, output_distribution) bind(C) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: nintervals integer(kind=c_int), intent(in) :: speed integer(kind=c_int), intent(in) :: freq real(kind=c_double), intent(in) :: emp_distribution (:,:) integer(kind=c_int), intent(in) :: k (:) real(kind=c_double), intent(out), allocatable :: output_distribution (:,:)","tags":"","loc":"interface/do_concurrent_output_distribution.html"},{"title":"do_concurrent_speeds – Matcha","text":"interface Called by interface~~do_concurrent_speeds~~CalledByGraph interface~do_concurrent_speeds do_concurrent_speeds proc~simulated_distribution simulated_distribution proc~simulated_distribution->interface~do_concurrent_speeds Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public module subroutine do_concurrent_speeds(history, speeds) bind(C) Implementation → Arguments Type Intent Optional Attributes Name type( t_cell_collection_bind_C_t ), intent(in) :: history (:) real(kind=c_double), intent(out), allocatable :: speeds (:)","tags":"","loc":"interface/do_concurrent_speeds.html"},{"title":"output_t – Matcha","text":"public interface output_t Functions private pure module function construct(input, history) result(output) Implementation → Construct a new output_t object Arguments Type Intent Optional Attributes Name type( input_t ), intent(in) :: input type( t_cell_collection_t ), intent(in) :: history (:) Return Value type( output_t )","tags":"","loc":"interface/output_t.html"},{"title":"simulated_distribution – Matcha","text":"interface private module function simulated_distribution(self) result(output_distribution) Implementation → Arguments Type Intent Optional Attributes Name class( output_t ), intent(in) :: self Return Value double precision,allocatable,(:,:) Description The result is a histogram calculated from the simulation output","tags":"","loc":"interface/simulated_distribution.html"},{"title":"my_num_cells – Matcha","text":"interface Called by interface~~my_num_cells~~CalledByGraph interface~my_num_cells output_t%my_num_cells program~main main program~main->interface~my_num_cells Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private pure module function my_num_cells(self) result(num_cells) Implementation → Arguments Type Intent Optional Attributes Name class( output_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/my_num_cells.html"},{"title":"values – Matcha","text":"interface private pure module function values(self) result(my_values) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real,allocatable,(:,:,:)","tags":"","loc":"interface/values.html"},{"title":"dx – Matcha","text":"interface private pure module function dx(self) result(my_dx) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real","tags":"","loc":"interface/dx.html"},{"title":"dy – Matcha","text":"interface private pure module function dy(self) result(my_dy) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real","tags":"","loc":"interface/dy.html"},{"title":"dz – Matcha","text":"interface private pure module function dz(self) result(my_dz) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real","tags":"","loc":"interface/dz.html"},{"title":"dt_stable – Matcha","text":"interface private pure module function dt_stable(self, alpha) result(my_dt) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self real, intent(in) :: alpha Return Value real Description Set the time step at 90% of the stability limit obtained generalizing to 3D the value provided for 2D by\nKassinos, S., & Alexiadis, A. (2024). Beyond Language: Applying MLX Transformers to Engineering Physics. \narXiv preprint arXiv:2410.04167.","tags":"","loc":"interface/dt_stable.html"},{"title":"laplacian – Matcha","text":"interface private pure module function laplacian(rhs) result(laplacian_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: rhs Return Value type( subdomain_t )","tags":"","loc":"interface/laplacian.html"},{"title":"multiply – Matcha","text":"interface private pure module function multiply(lhs, rhs) result(product) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in) :: lhs class( subdomain_t ), intent(in) :: rhs Return Value type( subdomain_t )","tags":"","loc":"interface/multiply.html"},{"title":"add – Matcha","text":"interface private pure module function add(lhs, rhs) result(total) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: lhs type( subdomain_t ), intent(in) :: rhs Return Value type( subdomain_t )","tags":"","loc":"interface/add.html"},{"title":"define – Matcha","text":"interface private module subroutine define(side, boundary_val, internal_val, n, self) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in) :: side real, intent(in) :: boundary_val real, intent(in) :: internal_val integer, intent(in) :: n number of grid points in each coordinate direction class( subdomain_t ), intent(out) :: self","tags":"","loc":"interface/define.html"},{"title":"step – Matcha","text":"interface private module subroutine step(alpha_dt, self) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in) :: alpha_dt class( subdomain_t ), intent(inout) :: self","tags":"","loc":"interface/step.html"},{"title":"assign_and_sync – Matcha","text":"interface private module subroutine assign_and_sync(lhs, rhs) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(out) :: lhs type( subdomain_t ), intent(in) :: rhs","tags":"","loc":"interface/assign_and_sync.html"},{"title":"num_cells – Matcha","text":"interface Called by interface~~num_cells~~CalledByGraph interface~num_cells input_t%num_cells proc~matcha matcha proc~matcha->interface~num_cells Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private pure module function num_cells(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_cells.html"},{"title":"num_positions – Matcha","text":"interface Called by interface~~num_positions~~CalledByGraph interface~num_positions input_t%num_positions proc~matcha matcha proc~matcha->interface~num_positions Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private pure module function num_positions(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_positions.html"},{"title":"num_dimensions – Matcha","text":"interface Called by interface~~num_dimensions~~CalledByGraph interface~num_dimensions input_t%num_dimensions proc~matcha matcha proc~matcha->interface~num_dimensions Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private pure module function num_dimensions(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_dimensions.html"},{"title":"num_intervals – Matcha","text":"interface Called by interface~~num_intervals~~CalledByGraph interface~num_intervals input_t%num_intervals proc~matcha matcha proc~matcha->interface~num_intervals Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private pure module function num_intervals(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_intervals.html"},{"title":"time_step – Matcha","text":"interface Called by interface~~time_step~~CalledByGraph interface~time_step input_t%time_step proc~matcha matcha proc~matcha->interface~time_step Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private pure module function time_step(self) result(dt) Implementation → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value double precision","tags":"","loc":"interface/time_step.html"},{"title":"sample_distribution – Matcha","text":"interface Called by interface~~sample_distribution~~CalledByGraph interface~sample_distribution input_t%sample_distribution proc~matcha matcha proc~matcha->interface~sample_distribution proc~simulated_distribution simulated_distribution proc~simulated_distribution->interface~sample_distribution Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private pure module function sample_distribution(self) result(empirical_distribution) Implementation → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value double precision,allocatable,(:,:)","tags":"","loc":"interface/sample_distribution.html"},{"title":"matcha – Matcha","text":"module procedure matcha module function matcha(input) result(history) Interface → Arguments Type Intent Optional Attributes Name type( input_t ), intent(in) :: input Return Value type( t_cell_collection_t ), allocatable, (:) Calls proc~~matcha~~CallsGraph proc~matcha matcha define_partitions define_partitions proc~matcha->define_partitions first first proc~matcha->first interface~num_cells input_t%num_cells proc~matcha->interface~num_cells interface~num_dimensions input_t%num_dimensions proc~matcha->interface~num_dimensions interface~num_intervals input_t%num_intervals proc~matcha->interface~num_intervals interface~num_positions input_t%num_positions proc~matcha->interface~num_positions interface~positions t_cell_collection_t%positions proc~matcha->interface~positions interface~sample_distribution input_t%sample_distribution proc~matcha->interface~sample_distribution interface~time_step input_t%time_step proc~matcha->interface~time_step last last proc~matcha->last random_4vectors random_4vectors proc~matcha->random_4vectors random_init random_init proc~matcha->random_init random_positions random_positions proc~matcha->random_positions velocities velocities proc~matcha->velocities Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/matcha.html"},{"title":"dt_stable – Matcha","text":"module procedure dt_stable pure module function dt_stable(self, alpha) result(my_dt) Interface → Set the time step at 90% of the stability limit obtained generalizing to 3D the value provided for 2D by\nKassinos, S., & Alexiadis, A. (2024). Beyond Language: Applying MLX Transformers to Engineering Physics. \narXiv preprint arXiv:2410.04167. Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self real, intent(in) :: alpha Return Value real","tags":"","loc":"proc/dt_stable.html"},{"title":"define – Matcha","text":"module procedure define module subroutine define(side, boundary_val, internal_val, n, self) Interface → Arguments Type Intent Optional Attributes Name real, intent(in) :: side real, intent(in) :: boundary_val real, intent(in) :: internal_val integer, intent(in) :: n number of grid points in each coordinate direction class( subdomain_t ), intent(out) :: self Calls proc~~define~~CallsGraph proc~define define assert assert proc~define->assert define_partitions define_partitions proc~define->define_partitions first first proc~define->first intrinsic_array_t intrinsic_array_t proc~define->intrinsic_array_t last last proc~define->last Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/define.html"},{"title":"dx – Matcha","text":"module procedure dx pure module function dx(self) result(my_dx) Interface → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real","tags":"","loc":"proc/dx.html"},{"title":"dy – Matcha","text":"module procedure dy pure module function dy(self) result(my_dy) Interface → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real","tags":"","loc":"proc/dy.html"},{"title":"dz – Matcha","text":"module procedure dz pure module function dz(self) result(my_dz) Interface → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real","tags":"","loc":"proc/dz.html"},{"title":"laplacian – Matcha","text":"module procedure laplacian pure module function laplacian(rhs) result(laplacian_rhs) Interface → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: rhs Return Value type( subdomain_t ) Calls proc~~laplacian~~CallsGraph proc~laplacian laplacian assert assert proc~laplacian->assert Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/laplacian.html"},{"title":"multiply – Matcha","text":"module procedure multiply pure module function multiply(lhs, rhs) result(product) Interface → Arguments Type Intent Optional Attributes Name real, intent(in) :: lhs class( subdomain_t ), intent(in) :: rhs Return Value type( subdomain_t ) Calls proc~~multiply~~CallsGraph proc~multiply multiply assert assert proc~multiply->assert Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/multiply.html"},{"title":"add – Matcha","text":"module procedure add pure module function add(lhs, rhs) result(total) Interface → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: lhs type( subdomain_t ), intent(in) :: rhs Return Value type( subdomain_t ) Calls proc~~add~~CallsGraph proc~add add assert assert proc~add->assert Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/add.html"},{"title":"assign_and_sync – Matcha","text":"module procedure assign_and_sync module subroutine assign_and_sync(lhs, rhs) Interface → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(out) :: lhs type( subdomain_t ), intent(in) :: rhs Calls proc~~assign_and_sync~~CallsGraph proc~assign_and_sync assign_and_sync assert assert proc~assign_and_sync->assert Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/assign_and_sync.html"},{"title":"values – Matcha","text":"module procedure values pure module function values(self) result(my_values) Interface → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real, allocatable, (:,:,:) Calls proc~~values~~CallsGraph proc~values values assert assert proc~values->assert Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/values.html"},{"title":"step – Matcha","text":"module procedure step module subroutine step(alpha_dt, self) Interface → Arguments Type Intent Optional Attributes Name real, intent(in) :: alpha_dt class( subdomain_t ), intent(inout) :: self Calls proc~~step~~CallsGraph proc~step step assert assert proc~step->assert Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/step.html"},{"title":"num_cells – Matcha","text":"module procedure num_cells pure module function num_cells(self) result(n) Interface → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer","tags":"","loc":"proc/num_cells.html"},{"title":"num_positions – Matcha","text":"module procedure num_positions pure module function num_positions(self) result(n) Interface → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer","tags":"","loc":"proc/num_positions.html"},{"title":"num_dimensions – Matcha","text":"module procedure num_dimensions pure module function num_dimensions(self) result(n) Interface → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer","tags":"","loc":"proc/num_dimensions.html"},{"title":"num_intervals – Matcha","text":"module procedure num_intervals pure module function num_intervals(self) result(n) Interface → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer","tags":"","loc":"proc/num_intervals.html"},{"title":"time_step – Matcha","text":"module procedure time_step pure module function time_step(self) result(dt) Interface → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value double precision","tags":"","loc":"proc/time_step.html"},{"title":"sample_distribution – Matcha","text":"module procedure sample_distribution pure module function sample_distribution(self) result(empirical_distribution) Interface → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value double precision, allocatable, (:,:)","tags":"","loc":"proc/sample_distribution.html"},{"title":"construct – Matcha","text":"module procedure construct pure module function construct(positions, time) result(t_cell_collection) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: positions (:,:) double precision, intent(in) :: time Return Value type( t_cell_collection_t )","tags":"","loc":"proc/construct.html"},{"title":"positions – Matcha","text":"module procedure positions pure module function positions(self) result(my_positions) Interface → Arguments Type Intent Optional Attributes Name class( t_cell_collection_t ), intent(in) :: self Return Value double precision, allocatable, (:,:) Calls proc~~positions~~CallsGraph proc~positions positions assert assert proc~positions->assert Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/positions.html"},{"title":"time – Matcha","text":"module procedure time elemental module function time(self) result(my_time) Interface → Arguments Type Intent Optional Attributes Name class( t_cell_collection_t ), intent(in) :: self Return Value double precision","tags":"","loc":"proc/time.html"},{"title":"construct_bind_C – Matcha","text":"module procedure construct_bind_C elemental module function construct_bind_C(t_cell_collection) result(t_cell_collection_bind_C) Arguments Type Intent Optional Attributes Name type( t_cell_collection_t ), intent(in), target :: t_cell_collection Return Value type( t_cell_collection_bind_C_t )","tags":"","loc":"proc/construct_bind_c.html"},{"title":"do_concurrent_sampled_speeds – Matcha","text":"module procedure do_concurrent_sampled_speeds pure module subroutine do_concurrent_sampled_speeds(speeds, vel, cumulative_distribution, sampled_speeds) Interface → Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: speeds (:,:) real(kind=c_double), intent(in) :: vel (:) real(kind=c_double), intent(in) :: cumulative_distribution (:) real(kind=c_double), intent(out), allocatable :: sampled_speeds (:,:)","tags":"","loc":"proc/do_concurrent_sampled_speeds.html"},{"title":"do_concurrent_my_velocities – Matcha","text":"module procedure do_concurrent_my_velocities pure module subroutine do_concurrent_my_velocities(nsteps, dir, sampled_speeds, my_velocities) Interface → Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: nsteps real(kind=c_double), intent(in) :: dir (:,:,:) real(kind=c_double), intent(in) :: sampled_speeds (:,:) real(kind=c_double), intent(out), allocatable :: my_velocities (:,:,:)","tags":"","loc":"proc/do_concurrent_my_velocities.html"},{"title":"do_concurrent_k – Matcha","text":"module procedure do_concurrent_k pure module subroutine do_concurrent_k(speeds, vel, k) Interface → Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: speeds (:) real(kind=c_double), intent(in) :: vel (:) integer(kind=c_int), intent(out), allocatable :: k (:)","tags":"","loc":"proc/do_concurrent_k.html"},{"title":"do_concurrent_output_distribution – Matcha","text":"module procedure do_concurrent_output_distribution pure module subroutine do_concurrent_output_distribution(nintervals, speed, freq, emp_distribution, k, output_distribution) Interface → Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: nintervals integer(kind=c_int), intent(in) :: speed integer(kind=c_int), intent(in) :: freq real(kind=c_double), intent(in) :: emp_distribution (:,:) integer(kind=c_int), intent(in) :: k (:) real(kind=c_double), intent(out), allocatable :: output_distribution (:,:)","tags":"","loc":"proc/do_concurrent_output_distribution.html"},{"title":"do_concurrent_speeds – Matcha","text":"module procedure do_concurrent_speeds module subroutine do_concurrent_speeds(history, speeds) Interface → Arguments Type Intent Optional Attributes Name type( t_cell_collection_bind_C_t ), intent(in) :: history (:) real(kind=c_double), intent(out), allocatable :: speeds (:) Calls proc~~do_concurrent_speeds~~CallsGraph proc~do_concurrent_speeds do_concurrent_speeds / / proc~do_concurrent_speeds->/ Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/do_concurrent_speeds.html"},{"title":"construct – Matcha","text":"module procedure construct pure module function construct(sample_distribution) result(distribution) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: sample_distribution (:,:) Return Value type( distribution_t ) Calls proc~~construct~2~~CallsGraph proc~construct~2 construct assert assert proc~construct~2->assert intrinsic_array_t intrinsic_array_t proc~construct~2->intrinsic_array_t proc~monotonically_increasing monotonically_increasing proc~construct~2->proc~monotonically_increasing Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/construct~2.html"},{"title":"cumulative_distribution – Matcha","text":"module procedure cumulative_distribution pure module function cumulative_distribution(self) result(my_cumulative_distribution) Interface → Arguments Type Intent Optional Attributes Name class( distribution_t ), intent(in) :: self Return Value double precision, allocatable, (:) Calls proc~~cumulative_distribution~~CallsGraph proc~cumulative_distribution cumulative_distribution assert assert proc~cumulative_distribution->assert Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/cumulative_distribution.html"},{"title":"velocities – Matcha","text":"module procedure velocities pure module function velocities(self, speeds, directions) result(my_velocities) Interface → Arguments Type Intent Optional Attributes Name class( distribution_t ), intent(in) :: self double precision, intent(in) :: speeds (:,:) double precision, intent(in) :: directions (:,:,:) Return Value double precision, allocatable, (:,:,:) Calls proc~~velocities~~CallsGraph proc~velocities velocities assert assert proc~velocities->assert interface~cumulative_distribution distribution_t%cumulative_distribution proc~velocities->interface~cumulative_distribution interface~do_concurrent_my_velocities do_concurrent_my_velocities proc~velocities->interface~do_concurrent_my_velocities interface~do_concurrent_sampled_speeds do_concurrent_sampled_speeds proc~velocities->interface~do_concurrent_sampled_speeds Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/velocities.html"},{"title":"construct – Matcha","text":"module procedure construct pure module function construct(input, history) result(output) Arguments Type Intent Optional Attributes Name type( input_t ), intent(in) :: input type( t_cell_collection_t ), intent(in) :: history (:) Return Value type( output_t )","tags":"","loc":"proc/construct~3.html"},{"title":"my_num_cells – Matcha","text":"module procedure my_num_cells pure module function my_num_cells(self) result(num_cells) Interface → Arguments Type Intent Optional Attributes Name class( output_t ), intent(in) :: self Return Value integer Calls proc~~my_num_cells~~CallsGraph proc~my_num_cells my_num_cells interface~positions t_cell_collection_t%positions proc~my_num_cells->interface~positions Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/my_num_cells.html"},{"title":"simulated_distribution – Matcha","text":"module procedure simulated_distribution module function simulated_distribution(self) result(output_distribution) Interface → Arguments Type Intent Optional Attributes Name class( output_t ), intent(in) :: self Return Value double precision, allocatable, (:,:) Calls proc~~simulated_distribution~~CallsGraph proc~simulated_distribution simulated_distribution interface~do_concurrent_k do_concurrent_k proc~simulated_distribution->interface~do_concurrent_k interface~do_concurrent_output_distribution do_concurrent_output_distribution proc~simulated_distribution->interface~do_concurrent_output_distribution interface~do_concurrent_speeds do_concurrent_speeds proc~simulated_distribution->interface~do_concurrent_speeds interface~sample_distribution input_t%sample_distribution proc~simulated_distribution->interface~sample_distribution Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/simulated_distribution.html"},{"title":"distribution_m – Matcha","text":"Used by Descendants: distribution_s module~~distribution_m~~UsedByGraph module~distribution_m distribution_m module~distribution_s distribution_s module~distribution_s->module~distribution_m module~do_concurrent_m do_concurrent_m module~distribution_s->module~do_concurrent_m module~matcha_m matcha_m module~matcha_m->module~distribution_m module~t_cell_collection_m t_cell_collection_m module~matcha_m->module~t_cell_collection_m module~output_m output_m module~matcha_m->module~output_m module~matcha_s matcha_s module~matcha_s->module~distribution_m module~matcha_s->module~matcha_m module~matcha_s->module~t_cell_collection_m module~t_cell_collection_m->module~distribution_m module~do_concurrent_m->module~t_cell_collection_m module~output_m->module~t_cell_collection_m module~output_s output_s module~output_s->module~t_cell_collection_m module~output_s->module~do_concurrent_m module~output_s->module~output_m module~t_cell_collection_s t_cell_collection_s module~t_cell_collection_s->module~t_cell_collection_m program~main main program~main->module~matcha_m module~do_concurrent_s do_concurrent_s module~do_concurrent_s->module~do_concurrent_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface distribution_t private pure module function construct(sample_distribution) result(distribution) Implementation → Arguments Type Intent Optional Attributes Name double precision, intent(in) :: sample_distribution (:,:) Return Value type( distribution_t ) interface private pure module function cumulative_distribution(self) result(my_cumulative_distribution) Implementation → Arguments Type Intent Optional Attributes Name class( distribution_t ), intent(in) :: self Return Value double precision, allocatable, (:) interface private pure module function velocities(self, speeds, directions) result(my_velocities) Implementation → Return the t_cell_collection_t object's velocity vectors Arguments Type Intent Optional Attributes Name class( distribution_t ), intent(in) :: self double precision, intent(in) :: speeds (:,:) double precision, intent(in) :: directions (:,:,:) Return Value double precision, allocatable, (:,:,:) Derived Types type, public :: distribution_t Components Type Visibility Attributes Name Initial double precision, private, allocatable, dimension(:) :: vel_ double precision, private, allocatable, dimension(:) :: cumulative_distribution_ Constructor private\n\n                    pure, module\n                    function construct (sample_distribution) Type-Bound Procedures procedure, public :: cumulative_distribution procedure, public :: velocities","tags":"","loc":"module/distribution_m.html"},{"title":"t_cell_collection_m – Matcha","text":"Define a T-cell abstraction for motility simulations Uses iso_c_binding distribution_m module~~t_cell_collection_m~~UsesGraph module~t_cell_collection_m t_cell_collection_m iso_c_binding iso_c_binding module~t_cell_collection_m->iso_c_binding module~distribution_m distribution_m module~t_cell_collection_m->module~distribution_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by Descendants: t_cell_collection_s module~~t_cell_collection_m~~UsedByGraph module~t_cell_collection_m t_cell_collection_m module~do_concurrent_m do_concurrent_m module~do_concurrent_m->module~t_cell_collection_m module~matcha_m matcha_m module~matcha_m->module~t_cell_collection_m module~output_m output_m module~matcha_m->module~output_m module~matcha_s matcha_s module~matcha_s->module~t_cell_collection_m module~matcha_s->module~matcha_m module~output_m->module~t_cell_collection_m module~output_s output_s module~output_s->module~t_cell_collection_m module~output_s->module~do_concurrent_m module~output_s->module~output_m module~t_cell_collection_s t_cell_collection_s module~t_cell_collection_s->module~t_cell_collection_m module~distribution_s distribution_s module~distribution_s->module~do_concurrent_m module~do_concurrent_s do_concurrent_s module~do_concurrent_s->module~do_concurrent_m program~main main program~main->module~matcha_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, private, parameter :: positions_dimension = 2 Interfaces public        interface t_cell_collection_t private pure module function construct(positions, time) result(t_cell_collection) Implementation → Return a t_cell_collection_t object with rescaled position vectors and the provided time stamp Arguments Type Intent Optional Attributes Name double precision, intent(in) :: positions (:,:) double precision, intent(in) :: time Return Value type( t_cell_collection_t ) public        interface t_cell_collection_bind_C_t private elemental module function construct_bind_C(t_cell_collection) result(t_cell_collection_bind_C) Implementation → Result is bind(C) representation of the data inside a t_cell_collection_t object Arguments Type Intent Optional Attributes Name type( t_cell_collection_t ), intent(in), target :: t_cell_collection Return Value type( t_cell_collection_bind_C_t ) interface private pure module function positions(self) result(my_positions) Implementation → Return the t_cell_collection_t object's position vectors Arguments Type Intent Optional Attributes Name class( t_cell_collection_t ), intent(in) :: self Return Value double precision, allocatable, (:,:) interface private elemental module function time(self) result(my_time) Implementation → Return the t_cell_collection_t object's time stamp Arguments Type Intent Optional Attributes Name class( t_cell_collection_t ), intent(in) :: self Return Value double precision Derived Types type, public :: t_cell_collection_t Encapsulate the state of a collection of T cells Components Type Visibility Attributes Name Initial double precision, private, allocatable :: positions_ (:,:) position vectors double precision, private :: time_ time stamp Constructor private\n\n                    pure, module\n                    function construct (positions, time) Return a t_cell_collection_t object with rescaled position vectors and the provided time stamp Type-Bound Procedures procedure, public :: positions procedure, public :: time type, public, bind(C) :: t_cell_collection_bind_C_t Components Type Visibility Attributes Name Initial type(c_ptr), public :: positions_ptr integer(kind=c_int), public :: positions_shape (positions_dimension) real(kind=c_double), public :: time Constructor private\n\n                    elemental, module\n                    function construct_bind_C (t_cell_collection) Result is bind(C) representation of the data inside a t_cell_collection_t object","tags":"","loc":"module/t_cell_collection_m.html"},{"title":"matcha_m – Matcha","text":"Uses input_m subdomain_m distribution_m output_m t_cell_collection_m module~~matcha_m~~UsesGraph module~matcha_m matcha_m module~distribution_m distribution_m module~matcha_m->module~distribution_m module~input_m input_m module~matcha_m->module~input_m module~output_m output_m module~matcha_m->module~output_m module~subdomain_m subdomain_m module~matcha_m->module~subdomain_m module~t_cell_collection_m t_cell_collection_m module~matcha_m->module~t_cell_collection_m module~output_m->module~input_m module~output_m->module~t_cell_collection_m module~t_cell_collection_m->module~distribution_m iso_c_binding iso_c_binding module~t_cell_collection_m->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by Descendants: matcha_s module~~matcha_m~~UsedByGraph module~matcha_m matcha_m module~matcha_s matcha_s module~matcha_s->module~matcha_m program~main main program~main->module~matcha_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces interface public module function matcha(input) result(history) Implementation → Arguments Type Intent Optional Attributes Name type( input_t ), intent(in) :: input Return Value type( t_cell_collection_t ), allocatable, (:)","tags":"","loc":"module/matcha_m.html"},{"title":"do_concurrent_m – Matcha","text":"Uses t_cell_collection_m iso_c_binding module~~do_concurrent_m~~UsesGraph module~do_concurrent_m do_concurrent_m iso_c_binding iso_c_binding module~do_concurrent_m->iso_c_binding module~t_cell_collection_m t_cell_collection_m module~do_concurrent_m->module~t_cell_collection_m module~t_cell_collection_m->iso_c_binding module~distribution_m distribution_m module~t_cell_collection_m->module~distribution_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by Descendants: do_concurrent_s module~~do_concurrent_m~~UsedByGraph module~do_concurrent_m do_concurrent_m module~distribution_s distribution_s module~distribution_s->module~do_concurrent_m module~do_concurrent_s do_concurrent_s module~do_concurrent_s->module~do_concurrent_m module~output_s output_s module~output_s->module~do_concurrent_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces interface public pure module subroutine do_concurrent_sampled_speeds(speeds, vel, cumulative_distribution, sampled_speeds) bind(C) Implementation → Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: speeds (:,:) real(kind=c_double), intent(in) :: vel (:) real(kind=c_double), intent(in) :: cumulative_distribution (:) real(kind=c_double), intent(out), allocatable :: sampled_speeds (:,:) interface public pure module subroutine do_concurrent_my_velocities(nsteps, dir, sampled_speeds, my_velocities) bind(C) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: nsteps real(kind=c_double), intent(in) :: dir (:,:,:) real(kind=c_double), intent(in) :: sampled_speeds (:,:) real(kind=c_double), intent(out), allocatable :: my_velocities (:,:,:) interface public pure module subroutine do_concurrent_k(speeds, vel, k) bind(C) Implementation → Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: speeds (:) real(kind=c_double), intent(in) :: vel (:) integer(kind=c_int), intent(out), allocatable :: k (:) interface public pure module subroutine do_concurrent_output_distribution(nintervals, speed, freq, emp_distribution, k, output_distribution) bind(C) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: nintervals integer(kind=c_int), intent(in) :: speed integer(kind=c_int), intent(in) :: freq real(kind=c_double), intent(in) :: emp_distribution (:,:) integer(kind=c_int), intent(in) :: k (:) real(kind=c_double), intent(out), allocatable :: output_distribution (:,:) interface public module subroutine do_concurrent_speeds(history, speeds) bind(C) Implementation → Arguments Type Intent Optional Attributes Name type( t_cell_collection_bind_C_t ), intent(in) :: history (:) real(kind=c_double), intent(out), allocatable :: speeds (:)","tags":"","loc":"module/do_concurrent_m.html"},{"title":"output_m – Matcha","text":"Output data abstraction Uses input_m t_cell_collection_m module~~output_m~~UsesGraph module~output_m output_m module~input_m input_m module~output_m->module~input_m module~t_cell_collection_m t_cell_collection_m module~output_m->module~t_cell_collection_m iso_c_binding iso_c_binding module~t_cell_collection_m->iso_c_binding module~distribution_m distribution_m module~t_cell_collection_m->module~distribution_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by Descendants: output_s module~~output_m~~UsedByGraph module~output_m output_m module~matcha_m matcha_m module~matcha_m->module~output_m module~output_s output_s module~output_s->module~output_m module~matcha_s matcha_s module~matcha_s->module~matcha_m program~main main program~main->module~matcha_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface output_t private pure module function construct(input, history) result(output) Implementation → Construct a new output_t object Arguments Type Intent Optional Attributes Name type( input_t ), intent(in) :: input type( t_cell_collection_t ), intent(in) :: history (:) Return Value type( output_t ) interface private module function simulated_distribution(self) result(output_distribution) Implementation → The result is a histogram calculated from the simulation output Arguments Type Intent Optional Attributes Name class( output_t ), intent(in) :: self Return Value double precision, allocatable, (:,:) interface private pure module function my_num_cells(self) result(num_cells) Implementation → Arguments Type Intent Optional Attributes Name class( output_t ), intent(in) :: self Return Value integer Derived Types type, public :: output_t Encapsulate an input/result pair Components Type Visibility Attributes Name Initial type( input_t ), private :: input_ type( t_cell_collection_t ), private, allocatable :: history_ (:) Constructor private\n\n                    pure, module\n                    function construct (input, history) Construct a new output_t object Type-Bound Procedures procedure, public :: simulated_distribution procedure, public :: my_num_cells","tags":"","loc":"module/output_m.html"},{"title":"subdomain_m – Matcha","text":"Used by Descendants: subdomain_s module~~subdomain_m~~UsedByGraph module~subdomain_m subdomain_m module~matcha_m matcha_m module~matcha_m->module~subdomain_m module~subdomain_s subdomain_s module~subdomain_s->module~subdomain_m module~matcha_s matcha_s module~matcha_s->module~matcha_m program~main main program~main->module~matcha_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces interface private pure module function values(self) result(my_values) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real, allocatable, (:,:,:) interface private pure module function dx(self) result(my_dx) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real interface private pure module function dy(self) result(my_dy) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real interface private pure module function dz(self) result(my_dz) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real interface private pure module function dt_stable(self, alpha) result(my_dt) Implementation → Set the time step at 90% of the stability limit obtained generalizing to 3D the value provided for 2D by\nKassinos, S., & Alexiadis, A. (2024). Beyond Language: Applying MLX Transformers to Engineering Physics. \narXiv preprint arXiv:2410.04167. Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self real, intent(in) :: alpha Return Value real interface private pure module function laplacian(rhs) result(laplacian_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: rhs Return Value type( subdomain_t ) interface private pure module function multiply(lhs, rhs) result(product) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in) :: lhs class( subdomain_t ), intent(in) :: rhs Return Value type( subdomain_t ) interface private pure module function add(lhs, rhs) result(total) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: lhs type( subdomain_t ), intent(in) :: rhs Return Value type( subdomain_t ) interface private module subroutine define(side, boundary_val, internal_val, n, self) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in) :: side real, intent(in) :: boundary_val real, intent(in) :: internal_val integer, intent(in) :: n number of grid points in each coordinate direction class( subdomain_t ), intent(out) :: self interface private module subroutine step(alpha_dt, self) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in) :: alpha_dt class( subdomain_t ), intent(inout) :: self interface private module subroutine assign_and_sync(lhs, rhs) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(out) :: lhs type( subdomain_t ), intent(in) :: rhs Derived Types type, public :: subdomain_t Components Type Visibility Attributes Name Initial real, private, allocatable :: s_ (:,:,:) Type-Bound Procedures procedure, public, pass(self) :: define procedure, public, pass(self) :: step procedure, public, pass(rhs) :: multiply generic, public :: operator(.laplacian.) => laplacian generic, public :: operator(*) => multiply generic, public :: operator(+) => add generic, public :: assignment(=) => assign_and_sync procedure, public :: dt_stable procedure, public :: dx procedure, public :: dy procedure, public :: dz procedure, public :: values procedure, private :: laplacian procedure, private :: add procedure, private :: assign_and_sync","tags":"","loc":"module/subdomain_m.html"},{"title":"input_m – Matcha","text":"Used by Descendants: input_s module~~input_m~~UsedByGraph module~input_m input_m module~input_s input_s module~input_s->module~input_m module~matcha_m matcha_m module~matcha_m->module~input_m module~output_m output_m module~matcha_m->module~output_m module~output_m->module~input_m module~matcha_s matcha_s module~matcha_s->module~matcha_m module~output_s output_s module~output_s->module~output_m program~main main program~main->module~matcha_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces interface private pure module function num_cells(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer interface private pure module function num_positions(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer interface private pure module function num_dimensions(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer interface private pure module function num_intervals(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer interface private pure module function time_step(self) result(dt) Implementation → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value double precision interface private pure module function sample_distribution(self) result(empirical_distribution) Implementation → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value double precision, allocatable, (:,:) Derived Types type, public :: input_t Components Type Visibility Attributes Name Initial integer, private :: num_cells_ = 6000 integer, private :: num_positions_ = 6000 integer, private :: num_dimensions_ = 3 integer, private :: num_intervals_ = 4 double precision, private :: time_step_ = 0.1D0 Type-Bound Procedures procedure, public :: num_cells procedure, public :: num_positions procedure, public :: num_dimensions procedure, public :: num_intervals procedure, public :: time_step procedure, public :: sample_distribution","tags":"","loc":"module/input_m.html"},{"title":"matcha_s – Matcha","text":"Uses sourcery_m t_cell_collection_m distribution_m Ancestors: matcha_m module~~matcha_s~~UsesGraph module~matcha_s matcha_s module~distribution_m distribution_m module~matcha_s->module~distribution_m module~matcha_m matcha_m module~matcha_s->module~matcha_m module~t_cell_collection_m t_cell_collection_m module~matcha_s->module~t_cell_collection_m sourcery_m sourcery_m module~matcha_s->sourcery_m module~matcha_m->module~distribution_m module~matcha_m->module~t_cell_collection_m module~input_m input_m module~matcha_m->module~input_m module~output_m output_m module~matcha_m->module~output_m module~subdomain_m subdomain_m module~matcha_m->module~subdomain_m module~t_cell_collection_m->module~distribution_m iso_c_binding iso_c_binding module~t_cell_collection_m->iso_c_binding module~output_m->module~t_cell_collection_m module~output_m->module~input_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Module Procedures module procedure /home/runner/work/matcha/matcha/doc/html/module/matcha_s.html matcha module function matcha(input) result(history) Interface → Arguments Type Intent Optional Attributes Name type( input_t ), intent(in) :: input Return Value type( t_cell_collection_t ), allocatable, (:)","tags":"","loc":"module/matcha_s.html"},{"title":"subdomain_s – Matcha","text":"Uses sourcery_m assert_m intrinsic_array_m Ancestors: subdomain_m module~~subdomain_s~~UsesGraph module~subdomain_s subdomain_s assert_m assert_m module~subdomain_s->assert_m intrinsic_array_m intrinsic_array_m module~subdomain_s->intrinsic_array_m module~subdomain_m subdomain_m module~subdomain_s->module~subdomain_m sourcery_m sourcery_m module~subdomain_s->sourcery_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial real, private, allocatable :: halo_x (:,:,:)[:] integer, private, parameter :: west = 1 integer, private, parameter :: east = 2 type(data_partition_t), private :: data_partition real, private :: dx_ real, private :: dy_ real, private :: dz_ integer, private :: my_nx integer, private :: nx integer, private :: ny integer, private :: nz integer, private :: me integer, private :: num_subdomains integer, private :: my_internal_west integer, private :: my_internal_east real, private, allocatable :: increment (:,:,:) Module Procedures module procedure /home/runner/work/matcha/matcha/doc/html/module/subdomain_s.html dt_stable pure module function dt_stable(self, alpha) result(my_dt) Interface → Set the time step at 90% of the stability limit obtained generalizing to 3D the value provided for 2D by\nKassinos, S., & Alexiadis, A. (2024). Beyond Language: Applying MLX Transformers to Engineering Physics. \narXiv preprint arXiv:2410.04167. Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self real, intent(in) :: alpha Return Value real module procedure /home/runner/work/matcha/matcha/doc/html/module/subdomain_s.html define module subroutine define(side, boundary_val, internal_val, n, self) Interface → Arguments Type Intent Optional Attributes Name real, intent(in) :: side real, intent(in) :: boundary_val real, intent(in) :: internal_val integer, intent(in) :: n number of grid points in each coordinate direction class( subdomain_t ), intent(out) :: self module procedure /home/runner/work/matcha/matcha/doc/html/module/subdomain_s.html dx pure module function dx(self) result(my_dx) Interface → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real module procedure /home/runner/work/matcha/matcha/doc/html/module/subdomain_s.html dy pure module function dy(self) result(my_dy) Interface → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real module procedure /home/runner/work/matcha/matcha/doc/html/module/subdomain_s.html dz pure module function dz(self) result(my_dz) Interface → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real module procedure /home/runner/work/matcha/matcha/doc/html/module/subdomain_s.html laplacian pure module function laplacian(rhs) result(laplacian_rhs) Interface → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: rhs Return Value type( subdomain_t ) module procedure /home/runner/work/matcha/matcha/doc/html/module/subdomain_s.html multiply pure module function multiply(lhs, rhs) result(product) Interface → Arguments Type Intent Optional Attributes Name real, intent(in) :: lhs class( subdomain_t ), intent(in) :: rhs Return Value type( subdomain_t ) module procedure /home/runner/work/matcha/matcha/doc/html/module/subdomain_s.html add pure module function add(lhs, rhs) result(total) Interface → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: lhs type( subdomain_t ), intent(in) :: rhs Return Value type( subdomain_t ) module procedure /home/runner/work/matcha/matcha/doc/html/module/subdomain_s.html assign_and_sync module subroutine assign_and_sync(lhs, rhs) Interface → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(out) :: lhs type( subdomain_t ), intent(in) :: rhs module procedure /home/runner/work/matcha/matcha/doc/html/module/subdomain_s.html values pure module function values(self) result(my_values) Interface → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real, allocatable, (:,:,:) module procedure /home/runner/work/matcha/matcha/doc/html/module/subdomain_s.html step module subroutine step(alpha_dt, self) Interface → Arguments Type Intent Optional Attributes Name real, intent(in) :: alpha_dt class( subdomain_t ), intent(inout) :: self","tags":"","loc":"module/subdomain_s.html"},{"title":"input_s – Matcha","text":"Uses Ancestors: input_m module~~input_s~~UsesGraph module~input_s input_s module~input_m input_m module~input_s->module~input_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Module Procedures module procedure /home/runner/work/matcha/matcha/doc/html/module/input_s.html num_cells pure module function num_cells(self) result(n) Interface → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer module procedure /home/runner/work/matcha/matcha/doc/html/module/input_s.html num_positions pure module function num_positions(self) result(n) Interface → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer module procedure /home/runner/work/matcha/matcha/doc/html/module/input_s.html num_dimensions pure module function num_dimensions(self) result(n) Interface → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer module procedure /home/runner/work/matcha/matcha/doc/html/module/input_s.html num_intervals pure module function num_intervals(self) result(n) Interface → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer module procedure /home/runner/work/matcha/matcha/doc/html/module/input_s.html time_step pure module function time_step(self) result(dt) Interface → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value double precision module procedure /home/runner/work/matcha/matcha/doc/html/module/input_s.html sample_distribution pure module function sample_distribution(self) result(empirical_distribution) Interface → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value double precision, allocatable, (:,:)","tags":"","loc":"module/input_s.html"},{"title":"t_cell_collection_s – Matcha","text":"Uses assert_m iso_c_binding Ancestors: t_cell_collection_m module~~t_cell_collection_s~~UsesGraph module~t_cell_collection_s t_cell_collection_s assert_m assert_m module~t_cell_collection_s->assert_m iso_c_binding iso_c_binding module~t_cell_collection_s->iso_c_binding module~t_cell_collection_m t_cell_collection_m module~t_cell_collection_s->module~t_cell_collection_m module~t_cell_collection_m->iso_c_binding module~distribution_m distribution_m module~t_cell_collection_m->module~distribution_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Module Procedures module procedure /home/runner/work/matcha/matcha/doc/html/module/t_cell_collection_s.html construct pure module function construct(positions, time) result(t_cell_collection) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: positions (:,:) double precision, intent(in) :: time Return Value type( t_cell_collection_t ) module procedure /home/runner/work/matcha/matcha/doc/html/module/t_cell_collection_s.html positions pure module function positions(self) result(my_positions) Interface → Arguments Type Intent Optional Attributes Name class( t_cell_collection_t ), intent(in) :: self Return Value double precision, allocatable, (:,:) module procedure /home/runner/work/matcha/matcha/doc/html/module/t_cell_collection_s.html time elemental module function time(self) result(my_time) Interface → Arguments Type Intent Optional Attributes Name class( t_cell_collection_t ), intent(in) :: self Return Value double precision module procedure /home/runner/work/matcha/matcha/doc/html/module/t_cell_collection_s.html construct_bind_C elemental module function construct_bind_C(t_cell_collection) result(t_cell_collection_bind_C) Arguments Type Intent Optional Attributes Name type( t_cell_collection_t ), intent(in), target :: t_cell_collection Return Value type( t_cell_collection_bind_C_t )","tags":"","loc":"module/t_cell_collection_s.html"},{"title":"do_concurrent_s – Matcha","text":"Uses iso_c_binding Ancestors: do_concurrent_m module~~do_concurrent_s~~UsesGraph module~do_concurrent_s do_concurrent_s iso_c_binding iso_c_binding module~do_concurrent_s->iso_c_binding module~do_concurrent_m do_concurrent_m module~do_concurrent_s->module~do_concurrent_m module~do_concurrent_m->iso_c_binding module~t_cell_collection_m t_cell_collection_m module~do_concurrent_m->module~t_cell_collection_m module~t_cell_collection_m->iso_c_binding module~distribution_m distribution_m module~t_cell_collection_m->module~distribution_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Module Procedures module procedure /home/runner/work/matcha/matcha/doc/html/module/do_concurrent_s.html do_concurrent_sampled_speeds pure module subroutine do_concurrent_sampled_speeds(speeds, vel, cumulative_distribution, sampled_speeds) Interface → Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: speeds (:,:) real(kind=c_double), intent(in) :: vel (:) real(kind=c_double), intent(in) :: cumulative_distribution (:) real(kind=c_double), intent(out), allocatable :: sampled_speeds (:,:) module procedure /home/runner/work/matcha/matcha/doc/html/module/do_concurrent_s.html do_concurrent_my_velocities pure module subroutine do_concurrent_my_velocities(nsteps, dir, sampled_speeds, my_velocities) Interface → Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: nsteps real(kind=c_double), intent(in) :: dir (:,:,:) real(kind=c_double), intent(in) :: sampled_speeds (:,:) real(kind=c_double), intent(out), allocatable :: my_velocities (:,:,:) module procedure /home/runner/work/matcha/matcha/doc/html/module/do_concurrent_s.html do_concurrent_k pure module subroutine do_concurrent_k(speeds, vel, k) Interface → Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: speeds (:) real(kind=c_double), intent(in) :: vel (:) integer(kind=c_int), intent(out), allocatable :: k (:) module procedure /home/runner/work/matcha/matcha/doc/html/module/do_concurrent_s.html do_concurrent_output_distribution pure module subroutine do_concurrent_output_distribution(nintervals, speed, freq, emp_distribution, k, output_distribution) Interface → Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: nintervals integer(kind=c_int), intent(in) :: speed integer(kind=c_int), intent(in) :: freq real(kind=c_double), intent(in) :: emp_distribution (:,:) integer(kind=c_int), intent(in) :: k (:) real(kind=c_double), intent(out), allocatable :: output_distribution (:,:) module procedure /home/runner/work/matcha/matcha/doc/html/module/do_concurrent_s.html do_concurrent_speeds module subroutine do_concurrent_speeds(history, speeds) Interface → Arguments Type Intent Optional Attributes Name type( t_cell_collection_bind_C_t ), intent(in) :: history (:) real(kind=c_double), intent(out), allocatable :: speeds (:)","tags":"","loc":"module/do_concurrent_s.html"},{"title":"distribution_s – Matcha","text":"Uses do_concurrent_m assert_m intrinsic_array_m Ancestors: distribution_m module~~distribution_s~~UsesGraph module~distribution_s distribution_s assert_m assert_m module~distribution_s->assert_m intrinsic_array_m intrinsic_array_m module~distribution_s->intrinsic_array_m module~distribution_m distribution_m module~distribution_s->module~distribution_m module~do_concurrent_m do_concurrent_m module~distribution_s->module~do_concurrent_m iso_c_binding iso_c_binding module~do_concurrent_m->iso_c_binding module~t_cell_collection_m t_cell_collection_m module~do_concurrent_m->module~t_cell_collection_m module~t_cell_collection_m->module~distribution_m module~t_cell_collection_m->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Functions pure function monotonically_increasing (f) result(monotonic) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: f (:) Return Value logical Module Procedures module procedure /home/runner/work/matcha/matcha/doc/html/module/distribution_s.html construct pure module function construct(sample_distribution) result(distribution) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: sample_distribution (:,:) Return Value type( distribution_t ) module procedure /home/runner/work/matcha/matcha/doc/html/module/distribution_s.html cumulative_distribution pure module function cumulative_distribution(self) result(my_cumulative_distribution) Interface → Arguments Type Intent Optional Attributes Name class( distribution_t ), intent(in) :: self Return Value double precision, allocatable, (:) module procedure /home/runner/work/matcha/matcha/doc/html/module/distribution_s.html velocities pure module function velocities(self, speeds, directions) result(my_velocities) Interface → Arguments Type Intent Optional Attributes Name class( distribution_t ), intent(in) :: self double precision, intent(in) :: speeds (:,:) double precision, intent(in) :: directions (:,:,:) Return Value double precision, allocatable, (:,:,:)","tags":"","loc":"module/distribution_s.html"},{"title":"output_s – Matcha","text":"Uses t_cell_collection_m iso_c_binding do_concurrent_m Ancestors: output_m module~~output_s~~UsesGraph module~output_s output_s iso_c_binding iso_c_binding module~output_s->iso_c_binding module~do_concurrent_m do_concurrent_m module~output_s->module~do_concurrent_m module~output_m output_m module~output_s->module~output_m module~t_cell_collection_m t_cell_collection_m module~output_s->module~t_cell_collection_m module~do_concurrent_m->iso_c_binding module~do_concurrent_m->module~t_cell_collection_m module~output_m->module~t_cell_collection_m module~input_m input_m module~output_m->module~input_m module~t_cell_collection_m->iso_c_binding module~distribution_m distribution_m module~t_cell_collection_m->module~distribution_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Module Procedures module procedure /home/runner/work/matcha/matcha/doc/html/module/output_s.html construct pure module function construct(input, history) result(output) Arguments Type Intent Optional Attributes Name type( input_t ), intent(in) :: input type( t_cell_collection_t ), intent(in) :: history (:) Return Value type( output_t ) module procedure /home/runner/work/matcha/matcha/doc/html/module/output_s.html my_num_cells pure module function my_num_cells(self) result(num_cells) Interface → Arguments Type Intent Optional Attributes Name class( output_t ), intent(in) :: self Return Value integer module procedure /home/runner/work/matcha/matcha/doc/html/module/output_s.html simulated_distribution module function simulated_distribution(self) result(output_distribution) Interface → Arguments Type Intent Optional Attributes Name class( output_t ), intent(in) :: self Return Value double precision, allocatable, (:,:)","tags":"","loc":"module/output_s.html"},{"title":"main – Matcha","text":"Uses matcha_m program~~main~~UsesGraph program~main main module~matcha_m matcha_m program~main->module~matcha_m module~distribution_m distribution_m module~matcha_m->module~distribution_m module~input_m input_m module~matcha_m->module~input_m module~output_m output_m module~matcha_m->module~output_m module~subdomain_m subdomain_m module~matcha_m->module~subdomain_m module~t_cell_collection_m t_cell_collection_m module~matcha_m->module~t_cell_collection_m module~output_m->module~input_m module~output_m->module~t_cell_collection_m module~t_cell_collection_m->module~distribution_m iso_c_binding iso_c_binding module~t_cell_collection_m->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Matcha: Motility Analysis of T-Cell Histories in Activation Calls program~~main~~CallsGraph program~main main interface~matcha matcha program~main->interface~matcha interface~my_num_cells output_t%my_num_cells program~main->interface~my_num_cells simulated_distribution simulated_distribution program~main->simulated_distribution Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( output_t ) :: output","tags":"","loc":"program/main.html"},{"title":"matcha_s.F90 – Matcha","text":"This file depends on sourcefile~~matcha_s.f90~~EfferentGraph sourcefile~matcha_s.f90 matcha_s.F90 sourcefile~distribution_m.f90 distribution_m.f90 sourcefile~matcha_s.f90->sourcefile~distribution_m.f90 sourcefile~matcha_m.f90 matcha_m.f90 sourcefile~matcha_s.f90->sourcefile~matcha_m.f90 sourcefile~t_cell_collection_m.f90 t_cell_collection_m.f90 sourcefile~matcha_s.f90->sourcefile~t_cell_collection_m.f90 sourcefile~matcha_m.f90->sourcefile~distribution_m.f90 sourcefile~matcha_m.f90->sourcefile~t_cell_collection_m.f90 sourcefile~input_m.f90 input_m.f90 sourcefile~matcha_m.f90->sourcefile~input_m.f90 sourcefile~output_m.f90 output_m.f90 sourcefile~matcha_m.f90->sourcefile~output_m.f90 sourcefile~subdomain_m.f90 subdomain_m.f90 sourcefile~matcha_m.f90->sourcefile~subdomain_m.f90 sourcefile~t_cell_collection_m.f90->sourcefile~distribution_m.f90 sourcefile~output_m.f90->sourcefile~t_cell_collection_m.f90 sourcefile~output_m.f90->sourcefile~input_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( matcha_m ) matcha_s use t_cell_collection_m , only : t_cell_collection_t use distribution_m , only : distribution_t use sourcery_m , only : data_partition_t implicit none contains module procedure matcha associate ( & ncells => input % num_cells (), & npositions => input % num_positions (), & ndim => input % num_dimensions (), & nintervals => input % num_intervals (), & dt => input % time_step (), & empirical_distribution => input % sample_distribution () & ) block double precision , parameter :: scale = 10 0.D0 double precision , allocatable :: random_positions (:,:), random_4vectors (:,:,:) type ( distribution_t ) distribution integer , parameter :: nveldim = 4 integer step type ( data_partition_t ) data_partition call data_partition % define_partitions ( cardinality = ncells ) associate ( me => this_image ()) associate ( my_num_cells => data_partition % last ( me ) - data_partition % first ( me ) + 1 ) call random_init ( repeatable = . true ., image_distinct = . true .) allocate ( random_positions ( my_num_cells , ndim )) call random_number ( random_positions ) associate ( nsteps => npositions - 1 ) allocate ( random_4vectors ( my_num_cells , nsteps , nveldim )) call random_number ( random_4vectors ) distribution = distribution_t ( empirical_distribution ) associate ( random_speeds => random_4vectors (:,:, 1 ), random_directions => random_4vectors (:,:, 2 : 4 )) associate ( v => distribution % velocities ( random_speeds , random_directions )) allocate ( history ( nsteps )) history ( 1 ) = t_cell_collection_t ( scale * random_positions , time = 0.D0 ) do step = 2 , nsteps associate ( x => history ( step - 1 )% positions (), t => history ( step - 1 )% time ()) history ( step ) = t_cell_collection_t ( x + v (:, step - 1 ,:) * dt , t + dt ) end associate end do end associate end associate end associate end associate end associate end block end associate end procedure end submodule matcha_s","tags":"","loc":"sourcefile/matcha_s.f90.html"},{"title":"subdomain_s.f90 – Matcha","text":"This file depends on sourcefile~~subdomain_s.f90~~EfferentGraph sourcefile~subdomain_s.f90 subdomain_s.f90 sourcefile~subdomain_m.f90 subdomain_m.f90 sourcefile~subdomain_s.f90->sourcefile~subdomain_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code submodule ( subdomain_m ) subdomain_s use sourcery_m , only : data_partition_t use assert_m , only : assert use intrinsic_array_m , only : intrinsic_array_t implicit none real , allocatable :: halo_x (:,:,:)[:] integer , parameter :: west = 1 , east = 2 type ( data_partition_t ) data_partition real dx_ , dy_ , dz_ integer my_nx , nx , ny , nz , me , num_subdomains , my_internal_west , my_internal_east real , allocatable :: increment (:,:,:) contains module procedure dt_stable !! Set the time step at 90% of the stability limit obtained generalizing to 3D the value provided for 2D by !! Kassinos, S., & Alexiadis, A. (2024). Beyond Language: Applying MLX Transformers to Engineering Physics. !! arXiv preprint arXiv:2410.04167. my_dt = 0.9 * ( 1. / ( 1. / dx_ ** 2 + 1. / dy_ ** 2 + 1. / dz_ ** 2 )) * ( 1. / ( 2. * alpha )) end procedure module procedure define integer , parameter :: nx_boundaries = 2 nx = n ny = nx nz = nx dx_ = side / ( nx - 1 ) dy_ = dx_ dz_ = dx_ call assert ( num_subdomains <= nx - nx_boundaries , & \"subdomain_t%define: num_subdomains <= nx-nx_boundaries\" , intrinsic_array_t ([ nx , num_subdomains ])) me = this_image () num_subdomains = num_images () call data_partition % define_partitions ( nx ) my_nx = data_partition % last ( me ) - data_partition % first ( me ) + 1 if ( allocated ( self % s_ )) deallocate ( self % s_ ) allocate ( self % s_ ( my_nx , ny , nz )) my_internal_west = merge ( 2 , 1 , me == 1 ) my_internal_east = merge ( my_nx - 1 , my_nx , me == num_subdomains ) self % s_ ( my_internal_west : my_internal_east , 2 : ny - 1 , 2 : nz - 1 ) = internal_val ! internal points self % s_ (:, : , 1 ) = boundary_val ! minimum z boundary self % s_ (:, : , nz ) = boundary_val ! maximum z boundary self % s_ (:, 1 , : ) = boundary_val ! minimum y boundary self % s_ (:, ny , : ) = boundary_val ! maximum y boundary if ( me == 1 ) self % s_ ( 1 , :, :) = boundary_val ! minimum x boundary if ( me == num_subdomains ) self % s_ ( my_nx , :, :) = boundary_val ! maximum x boundary if ( allocated ( halo_x )) deallocate ( halo_x ) allocate ( halo_x ( west : east , ny , nz )[ * ]) if ( me > 1 ) halo_x ( east ,:,:)[ me - 1 ] = self % s_ ( 1 ,:,:) if ( me < num_subdomains ) halo_x ( west ,:,:)[ me + 1 ] = self % s_ ( my_nx ,:,:) sync all end procedure module procedure dx my_dx = dx_ end procedure module procedure dy my_dy = dy_ end procedure module procedure dz my_dz = dz_ end procedure module procedure laplacian integer i , j , k real , allocatable :: halo_west (:,:), halo_east (:,:) call assert ( allocated ( rhs % s_ ), \"subdomain_t%laplacian: allocated(rhs%s_)\" ) call assert ( allocated ( halo_x ), \"subdomain_t%laplacian: allocated(halo_x)\" ) allocate ( laplacian_rhs % s_ ( my_nx , ny , nz )) halo_west = merge ( halo_x ( west ,:,:), rhs % s_ ( 1 ,:,:), me /= 1 ) i = my_internal_west call assert ( i + 1 <= my_nx , \"laplacian: westernmost subdomain too small\" ) do concurrent ( j = 2 : ny - 1 , k = 2 : nz - 1 ) laplacian_rhs % s_ ( i , j , k ) = ( halo_west ( j , k ) - 2 * rhs % s_ ( i , j , k ) + rhs % s_ ( i + 1 , j , k )) / dx_ ** 2 + & ( rhs % s_ ( i , j - 1 , k ) - 2 * rhs % s_ ( i , j , k ) + rhs % s_ ( i , j + 1 , k )) / dy_ ** 2 + & ( rhs % s_ ( i , j , k - 1 ) - 2 * rhs % s_ ( i , j , k ) + rhs % s_ ( i , j , k + 1 )) / dz_ ** 2 end do do concurrent ( i = my_internal_west + 1 : my_internal_east - 1 , j = 2 : ny - 1 , k = 2 : nz - 1 ) laplacian_rhs % s_ ( i , j , k ) = ( rhs % s_ ( i - 1 , j , k ) - 2 * rhs % s_ ( i , j , k ) + rhs % s_ ( i + 1 , j , k )) / dx_ ** 2 + & ( rhs % s_ ( i , j - 1 , k ) - 2 * rhs % s_ ( i , j , k ) + rhs % s_ ( i , j + 1 , k )) / dy_ ** 2 + & ( rhs % s_ ( i , j , k - 1 ) - 2 * rhs % s_ ( i , j , k ) + rhs % s_ ( i , j , k + 1 )) / dz_ ** 2 end do halo_east = merge ( halo_x ( east ,:,:), rhs % s_ ( my_nx ,:,:), me /= num_subdomains ) i = my_internal_east call assert ( i - 1 > 0 , \"laplacian: easternmost subdomain too small\" ) do concurrent ( j = 2 : ny - 1 , k = 2 : nz - 1 ) laplacian_rhs % s_ ( i , j , k ) = ( rhs % s_ ( i - 1 , j , k ) - 2 * rhs % s_ ( i , j , k ) + halo_east ( j , k )) / dx_ ** 2 + & ( rhs % s_ ( i , j - 1 , k ) - 2 * rhs % s_ ( i , j , k ) + rhs % s_ ( i , j + 1 , k )) / dy_ ** 2 + & ( rhs % s_ ( i , j , k - 1 ) - 2 * rhs % s_ ( i , j , k ) + rhs % s_ ( i , j , k + 1 )) / dz_ ** 2 end do laplacian_rhs % s_ (:, 1 ,:) = 0. laplacian_rhs % s_ (:, ny ,:) = 0. laplacian_rhs % s_ (:,:, 1 ) = 0. laplacian_rhs % s_ (:,:, nz ) = 0. if ( me == 1 ) laplacian_rhs % s_ ( 1 ,:,:) = 0. if ( me == num_subdomains ) laplacian_rhs % s_ ( my_nx ,:,:) = 0. end procedure module procedure multiply call assert ( allocated ( rhs % s_ ), \"subdomain_t%multiply: allocated(rhs%s_)\" ) product % s_ = lhs * rhs % s_ end procedure module procedure add call assert ( allocated ( rhs % s_ ), \"subdomain_t%add: allocated(rhs%s_)\" ) total % s_ = lhs % s_ + rhs % s_ end procedure module procedure assign_and_sync call assert ( allocated ( rhs % s_ ), \"subdomain_t%assign_and_sync: allocated(rhs%s_)\" ) sync all lhs % s_ = rhs % s_ if ( me > 1 ) halo_x ( east ,:,:)[ me - 1 ] = rhs % s_ ( 1 ,:,:) if ( me < num_subdomains ) halo_x ( west ,:,:)[ me + 1 ] = rhs % s_ ( my_nx ,:,:) sync all end procedure module procedure values call assert ( allocated ( self % s_ ), \"subdomain_t%values: allocated(self%s_)\" ) my_values = self % s_ end procedure module procedure step call assert ( allocated ( self % s_ ), \"subdomain_t%laplacian: allocated(rhs%s_)\" ) call assert ( allocated ( halo_x ), \"subdomain_t%laplacian: allocated(halo_x)\" ) call assert ( my_internal_west + 1 <= my_nx , \"laplacian: westernmost subdomain too small\" ) call assert ( my_internal_east - 1 > 0 , \"laplacian: easternmost subdomain too small\" ) if (. not . allocated ( increment )) allocate ( increment ( my_nx , ny , nz )) call internal_points ( increment ) call edge_points ( increment ) call apply_boundary_condition ( increment ) sync all self % s_ = self % s_ + increment sync all call exchange_halo ( self % s_ ) contains subroutine internal_points ( ds ) real , intent ( inout ) :: ds (:,:,:) integer i , j , k do concurrent ( i = my_internal_west + 1 : my_internal_east - 1 , j = 2 : ny - 1 , k = 2 : nz - 1 ) ds ( i , j , k ) = alpha_dt * ( & ( self % s_ ( i - 1 , j , k ) - 2 * self % s_ ( i , j , k ) + self % s_ ( i + 1 , j , k )) / dx_ ** 2 + & ( self % s_ ( i , j - 1 , k ) - 2 * self % s_ ( i , j , k ) + self % s_ ( i , j + 1 , k )) / dy_ ** 2 + & ( self % s_ ( i , j , k - 1 ) - 2 * self % s_ ( i , j , k ) + self % s_ ( i , j , k + 1 )) / dz_ ** 2 & ) end do end subroutine subroutine edge_points ( ds ) real , intent ( inout ) :: ds (:,:,:) real , allocatable :: halo_west (:,:), halo_east (:,:) integer i , j , k halo_west = merge ( halo_x ( west ,:,:), self % s_ ( 1 , :,:), me /= 1 ) halo_east = merge ( halo_x ( east ,:,:), self % s_ ( my_nx ,:,:), me /= num_subdomains ) i = my_internal_west do concurrent ( j = 2 : ny - 1 , k = 2 : nz - 1 ) ds ( i , j , k ) = alpha_dt * ( & ( halo_west ( j , k ) - 2 * self % s_ ( i , j , k ) + self % s_ ( i + 1 , j , k )) / dx_ ** 2 + & ( self % s_ ( i , j - 1 , k ) - 2 * self % s_ ( i , j , k ) + self % s_ ( i , j + 1 , k )) / dy_ ** 2 + & ( self % s_ ( i , j , k - 1 ) - 2 * self % s_ ( i , j , k ) + self % s_ ( i , j , k + 1 )) / dz_ ** 2 & ) end do i = my_internal_east do concurrent ( j = 2 : ny - 1 , k = 2 : nz - 1 ) ds ( i , j , k ) = alpha_dt * ( & ( self % s_ ( i - 1 , j , k ) - 2 * self % s_ ( i , j , k ) + halo_east ( j , k )) / dx_ ** 2 + & ( self % s_ ( i , j - 1 , k ) - 2 * self % s_ ( i , j , k ) + self % s_ ( i , j + 1 , k )) / dy_ ** 2 + & ( self % s_ ( i , j , k - 1 ) - 2 * self % s_ ( i , j , k ) + self % s_ ( i , j , k + 1 )) / dz_ ** 2 & ) end do end subroutine subroutine apply_boundary_condition ( ds ) real , intent ( inout ) :: ds (:,:,:) integer i , j ds (:, 1 : ny : ny - 1 , : ) = 0. ds (:, : , 1 : nz : nz - 1 ) = 0. if ( me == 1 ) ds ( 1 ,:,:) = 0. if ( me == num_subdomains ) ds ( my_nx ,:,:) = 0. end subroutine subroutine exchange_halo ( s ) real , intent ( in ) :: s (:,:,:) if ( me > 1 ) halo_x ( east ,:,:)[ me - 1 ] = s ( 1 ,:,:) if ( me < num_subdomains ) halo_x ( west ,:,:)[ me + 1 ] = s ( my_nx ,:,:) end subroutine end procedure end submodule subdomain_s","tags":"","loc":"sourcefile/subdomain_s.f90.html"},{"title":"distribution_m.f90 – Matcha","text":"Files dependent on this one sourcefile~~distribution_m.f90~~AfferentGraph sourcefile~distribution_m.f90 distribution_m.f90 sourcefile~distribution_s.f90 distribution_s.F90 sourcefile~distribution_s.f90->sourcefile~distribution_m.f90 sourcefile~do_concurrent_m.f90 do_concurrent_m.f90 sourcefile~distribution_s.f90->sourcefile~do_concurrent_m.f90 sourcefile~matcha_m.f90 matcha_m.f90 sourcefile~matcha_m.f90->sourcefile~distribution_m.f90 sourcefile~t_cell_collection_m.f90 t_cell_collection_m.f90 sourcefile~matcha_m.f90->sourcefile~t_cell_collection_m.f90 sourcefile~output_m.f90 output_m.f90 sourcefile~matcha_m.f90->sourcefile~output_m.f90 sourcefile~matcha_s.f90 matcha_s.F90 sourcefile~matcha_s.f90->sourcefile~distribution_m.f90 sourcefile~matcha_s.f90->sourcefile~matcha_m.f90 sourcefile~matcha_s.f90->sourcefile~t_cell_collection_m.f90 sourcefile~t_cell_collection_m.f90->sourcefile~distribution_m.f90 sourcefile~do_concurrent_m.f90->sourcefile~t_cell_collection_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~matcha_m.f90 sourcefile~output_m.f90->sourcefile~t_cell_collection_m.f90 sourcefile~output_s.f90 output_s.f90 sourcefile~output_s.f90->sourcefile~t_cell_collection_m.f90 sourcefile~output_s.f90->sourcefile~do_concurrent_m.f90 sourcefile~output_s.f90->sourcefile~output_m.f90 sourcefile~t_cell_collection_s.f90 t_cell_collection_s.F90 sourcefile~t_cell_collection_s.f90->sourcefile~t_cell_collection_m.f90 sourcefile~do_concurrent_s.f90 do_concurrent_s.f90 sourcefile~do_concurrent_s.f90->sourcefile~do_concurrent_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module distribution_m implicit none private public :: distribution_t type distribution_t private double precision , allocatable , dimension (:) :: vel_ , cumulative_distribution_ contains procedure :: cumulative_distribution procedure :: velocities end type interface distribution_t pure module function construct ( sample_distribution ) result ( distribution ) implicit none double precision , intent ( in ) :: sample_distribution (:,:) type ( distribution_t ) distribution end function end interface interface pure module function cumulative_distribution ( self ) result ( my_cumulative_distribution ) implicit none class ( distribution_t ), intent ( in ) :: self double precision , allocatable :: my_cumulative_distribution (:) end function pure module function velocities ( self , speeds , directions ) result ( my_velocities ) !! Return the t_cell_collection_t object's velocity vectors implicit none class ( distribution_t ), intent ( in ) :: self double precision , intent ( in ) :: speeds (:,:), directions (:,:,:) double precision , allocatable :: my_velocities (:,:,:) end function velocities end interface end module distribution_m","tags":"","loc":"sourcefile/distribution_m.f90.html"},{"title":"t_cell_collection_m.f90 – Matcha","text":"This file depends on sourcefile~~t_cell_collection_m.f90~~EfferentGraph sourcefile~t_cell_collection_m.f90 t_cell_collection_m.f90 sourcefile~distribution_m.f90 distribution_m.f90 sourcefile~t_cell_collection_m.f90->sourcefile~distribution_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~t_cell_collection_m.f90~~AfferentGraph sourcefile~t_cell_collection_m.f90 t_cell_collection_m.f90 sourcefile~do_concurrent_m.f90 do_concurrent_m.f90 sourcefile~do_concurrent_m.f90->sourcefile~t_cell_collection_m.f90 sourcefile~matcha_m.f90 matcha_m.f90 sourcefile~matcha_m.f90->sourcefile~t_cell_collection_m.f90 sourcefile~output_m.f90 output_m.f90 sourcefile~matcha_m.f90->sourcefile~output_m.f90 sourcefile~matcha_s.f90 matcha_s.F90 sourcefile~matcha_s.f90->sourcefile~t_cell_collection_m.f90 sourcefile~matcha_s.f90->sourcefile~matcha_m.f90 sourcefile~output_m.f90->sourcefile~t_cell_collection_m.f90 sourcefile~output_s.f90 output_s.f90 sourcefile~output_s.f90->sourcefile~t_cell_collection_m.f90 sourcefile~output_s.f90->sourcefile~do_concurrent_m.f90 sourcefile~output_s.f90->sourcefile~output_m.f90 sourcefile~t_cell_collection_s.f90 t_cell_collection_s.F90 sourcefile~t_cell_collection_s.f90->sourcefile~t_cell_collection_m.f90 sourcefile~distribution_s.f90 distribution_s.F90 sourcefile~distribution_s.f90->sourcefile~do_concurrent_m.f90 sourcefile~do_concurrent_s.f90 do_concurrent_s.f90 sourcefile~do_concurrent_s.f90->sourcefile~do_concurrent_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~matcha_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module t_cell_collection_m !! Define a T-cell abstraction for motility simulations use distribution_m , only : distribution_t use iso_c_binding , only : c_ptr , c_double , c_int implicit none private public :: t_cell_collection_t public :: t_cell_collection_bind_C_t type t_cell_collection_t !! Encapsulate the state of a collection of T cells private double precision , allocatable :: positions_ (:,:) !! position vectors double precision time_ !! time stamp contains procedure :: positions procedure :: time end type integer , parameter :: positions_dimension = 2 type , bind ( C ) :: t_cell_collection_bind_C_t type ( c_ptr ) positions_ptr integer ( c_int ) positions_shape ( positions_dimension ) real ( c_double ) time end type interface t_cell_collection_t pure module function construct ( positions , time ) result ( t_cell_collection ) !! Return a t_cell_collection_t object with rescaled position vectors and the provided time stamp implicit none double precision , intent ( in ) :: positions (:,:), time type ( t_cell_collection_t ) t_cell_collection end function end interface interface t_cell_collection_bind_C_t elemental module function construct_bind_C ( t_cell_collection ) result ( t_cell_collection_bind_C ) !! Result is bind(C) representation of the data inside a t_cell_collection_t object implicit none type ( t_cell_collection_t ), intent ( in ), target :: t_cell_collection type ( t_cell_collection_bind_C_t ) t_cell_collection_bind_C end function end interface interface pure module function positions ( self ) result ( my_positions ) !! Return the t_cell_collection_t object's position vectors implicit none class ( t_cell_collection_t ), intent ( in ) :: self double precision , allocatable :: my_positions (:,:) end function elemental module function time ( self ) result ( my_time ) !! Return the t_cell_collection_t object's time stamp implicit none class ( t_cell_collection_t ), intent ( in ) :: self double precision my_time end function end interface end module t_cell_collection_m","tags":"","loc":"sourcefile/t_cell_collection_m.f90.html"},{"title":"input_s.f90 – Matcha","text":"This file depends on sourcefile~~input_s.f90~~EfferentGraph sourcefile~input_s.f90 input_s.f90 sourcefile~input_m.f90 input_m.f90 sourcefile~input_s.f90->sourcefile~input_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( input_m ) input_s implicit none contains module procedure num_cells n = self % num_cells_ end procedure module procedure num_positions n = self % num_positions_ end procedure module procedure num_dimensions n = self % num_dimensions_ end procedure module procedure num_intervals n = self % num_intervals_ end procedure module procedure time_step dt = self % time_step_ end procedure module procedure sample_distribution integer i , nintervals double precision speed_lower , speed_upper double precision range , pi , dspeed , sumy double precision speed_lower_bin double precision speed_upper_bin double precision speed_middle_bin double precision , allocatable :: speeds (:), probability (:) nintervals = self % num_intervals_ speed_lower = 0.d0 speed_upper = 6.d0 range = speed_upper - speed_lower pi = acos ( - 1.d0 ) dspeed = range / dble ( nintervals ) allocate ( speeds ( nintervals ), probability ( nintervals )) !    Create normal distribution sumy = 0.d0 do i = 1 , nintervals speed_lower_bin = speed_lower + dble ( i - 1 ) * dspeed speed_upper_bin = speed_lower + dble ( i ) * dspeed speed_middle_bin = 0.5d0 * ( speed_lower_bin + speed_upper_bin ) speeds ( i ) = speed_middle_bin probability ( i ) = exp ( - ( speeds ( i ) - 3.d0 ) ** 2 / 2.d0 ) / dsqrt ( 2.d0 * pi ) ! Use normal distribution sumy = sumy + probability ( i ) end do do i = 1 , nintervals probability ( i ) = probability ( i ) / sumy end do allocate ( empirical_distribution ( nintervals , 2 )) do i = 1 , nintervals empirical_distribution ( i , 1 ) = speeds ( i ) empirical_distribution ( i , 2 ) = probability ( i ) end do end procedure end submodule input_s","tags":"","loc":"sourcefile/input_s.f90.html"},{"title":"t_cell_collection_s.F90 – Matcha","text":"This file depends on sourcefile~~t_cell_collection_s.f90~~EfferentGraph sourcefile~t_cell_collection_s.f90 t_cell_collection_s.F90 sourcefile~t_cell_collection_m.f90 t_cell_collection_m.f90 sourcefile~t_cell_collection_s.f90->sourcefile~t_cell_collection_m.f90 sourcefile~distribution_m.f90 distribution_m.f90 sourcefile~t_cell_collection_m.f90->sourcefile~distribution_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( t_cell_collection_m ) t_cell_collection_s use iso_c_binding , only : c_loc use assert_m , only : assert implicit none contains module procedure construct t_cell_collection % positions_ = positions t_cell_collection % time_ = time end procedure module procedure positions call assert ( allocated ( self % positions_ ), \"t_cell_collection_t%positions: allocated(positions_)\" ) my_positions = self % positions_ end procedure module procedure time my_time = self % time_ end procedure module procedure construct_bind_C t_cell_collection_bind_C % positions_ptr = c_loc ( t_cell_collection % positions_ ) t_cell_collection_bind_C % positions_shape = shape ( t_cell_collection % positions_ ) t_cell_collection_bind_C % time = t_cell_collection % time_ end procedure end submodule t_cell_collection_s","tags":"","loc":"sourcefile/t_cell_collection_s.f90.html"},{"title":"do_concurrent_s.f90 – Matcha","text":"This file depends on sourcefile~~do_concurrent_s.f90~~EfferentGraph sourcefile~do_concurrent_s.f90 do_concurrent_s.f90 sourcefile~do_concurrent_m.f90 do_concurrent_m.f90 sourcefile~do_concurrent_s.f90->sourcefile~do_concurrent_m.f90 sourcefile~t_cell_collection_m.f90 t_cell_collection_m.f90 sourcefile~do_concurrent_m.f90->sourcefile~t_cell_collection_m.f90 sourcefile~distribution_m.f90 distribution_m.f90 sourcefile~t_cell_collection_m.f90->sourcefile~distribution_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code submodule ( do_concurrent_m ) do_concurrent_s use iso_c_binding , only : c_f_pointer implicit none contains module procedure do_concurrent_sampled_speeds integer cell , step associate ( ncells => size ( speeds , 1 ), nsteps => size ( speeds , 2 )) allocate ( sampled_speeds ( ncells , nsteps )) do concurrent ( cell = 1 : ncells , step = 1 : nsteps ) associate ( k => findloc ( speeds ( cell , step ) >= cumulative_distribution , value = . false ., dim = 1 ) - 1 ) sampled_speeds ( cell , step ) = vel ( k ) end associate end do end associate end procedure module procedure do_concurrent_my_velocities integer step if ( allocated ( my_velocities )) deallocate ( my_velocities ) allocate ( my_velocities , mold = dir ) do concurrent ( step = 1 : nsteps ) my_velocities (:, step , 1 ) = sampled_speeds (:, step ) * dir (:, step , 1 ) my_velocities (:, step , 2 ) = sampled_speeds (:, step ) * dir (:, step , 2 ) my_velocities (:, step , 3 ) = sampled_speeds (:, step ) * dir (:, step , 3 ) end do end procedure module procedure do_concurrent_k integer i associate ( nspeeds => size ( speeds )) if ( allocated ( k )) deallocate ( k ) allocate ( k ( nspeeds )) do concurrent ( i = 1 : nspeeds ) k ( i ) = findloc ( speeds ( i ) >= vel , value = . false ., dim = 1 ) - 1 end do end associate end procedure module procedure do_concurrent_output_distribution integer i if ( allocated ( output_distribution )) deallocate ( output_distribution ) allocate ( output_distribution ( nintervals , 2 )) output_distribution (:, freq ) = 0.d0 output_distribution (:, speed ) = emp_distribution (:, speed ) do concurrent ( i = 1 : size ( output_distribution , 1 )) output_distribution ( i , freq ) = count ( k == i ) end do end procedure module procedure do_concurrent_speeds integer i , j , k integer , parameter :: nspacedims = 3 real ( c_double ), pointer :: positions (:,:) real ( c_double ), allocatable :: x (:,:,:) associate ( npositions => size ( history ), ncells => history ( 1 )% positions_shape ( 1 )) allocate ( x ( npositions , ncells , nspacedims )) do i = 1 , npositions call c_f_pointer ( history ( i )% positions_ptr , positions , history ( 1 )% positions_shape ) x ( i ,:,:) = positions end do associate ( t => history % time ) allocate ( speeds ( ncells * ( npositions - 1 ))) do concurrent ( i = 1 : npositions - 1 , j = 1 : ncells ) associate ( & u => ( x ( i + 1 , j ,:) - x ( i , j ,:)) / ( t ( i + 1 ) - t ( i )), & ij => i + ( j - 1 ) * ( npositions - 1 ) & ) speeds ( ij ) = sqrt ( sum ([( u ( k ) ** 2 , k = 1 , nspacedims )])) end associate end do end associate end associate end procedure end submodule do_concurrent_s","tags":"","loc":"sourcefile/do_concurrent_s.f90.html"},{"title":"matcha_m.f90 – Matcha","text":"This file depends on sourcefile~~matcha_m.f90~~EfferentGraph sourcefile~matcha_m.f90 matcha_m.f90 sourcefile~distribution_m.f90 distribution_m.f90 sourcefile~matcha_m.f90->sourcefile~distribution_m.f90 sourcefile~input_m.f90 input_m.f90 sourcefile~matcha_m.f90->sourcefile~input_m.f90 sourcefile~output_m.f90 output_m.f90 sourcefile~matcha_m.f90->sourcefile~output_m.f90 sourcefile~subdomain_m.f90 subdomain_m.f90 sourcefile~matcha_m.f90->sourcefile~subdomain_m.f90 sourcefile~t_cell_collection_m.f90 t_cell_collection_m.f90 sourcefile~matcha_m.f90->sourcefile~t_cell_collection_m.f90 sourcefile~output_m.f90->sourcefile~input_m.f90 sourcefile~output_m.f90->sourcefile~t_cell_collection_m.f90 sourcefile~t_cell_collection_m.f90->sourcefile~distribution_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~matcha_m.f90~~AfferentGraph sourcefile~matcha_m.f90 matcha_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~matcha_m.f90 sourcefile~matcha_s.f90 matcha_s.F90 sourcefile~matcha_s.f90->sourcefile~matcha_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module matcha_m use t_cell_collection_m , only : t_cell_collection_t use distribution_m , only : distribution_t use input_m , only : input_t use output_m , only : output_t use subdomain_m , only : subdomain_t implicit none interface module function matcha ( input ) result ( history ) implicit none type ( input_t ), intent ( in ) :: input type ( t_cell_collection_t ), allocatable :: history (:) end function end interface end module","tags":"","loc":"sourcefile/matcha_m.f90.html"},{"title":"distribution_s.F90 – Matcha","text":"This file depends on sourcefile~~distribution_s.f90~~EfferentGraph sourcefile~distribution_s.f90 distribution_s.F90 sourcefile~distribution_m.f90 distribution_m.f90 sourcefile~distribution_s.f90->sourcefile~distribution_m.f90 sourcefile~do_concurrent_m.f90 do_concurrent_m.f90 sourcefile~distribution_s.f90->sourcefile~do_concurrent_m.f90 sourcefile~t_cell_collection_m.f90 t_cell_collection_m.f90 sourcefile~do_concurrent_m.f90->sourcefile~t_cell_collection_m.f90 sourcefile~t_cell_collection_m.f90->sourcefile~distribution_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.tx submodule ( distribution_m ) distribution_s use intrinsic_array_m , only : intrinsic_array_t use do_concurrent_m , only : do_concurrent_sampled_speeds , do_concurrent_my_velocities use assert_m , only : assert implicit none contains pure function monotonically_increasing ( f ) result ( monotonic ) double precision , intent ( in ) :: f (:) logical monotonic integer i monotonic = all ([( f ( i + 1 ) >= f ( i ), i = 1 , size ( f ) - 1 )]) end function module procedure construct integer i call assert ( all ( sample_distribution (:, 2 ) >= 0.D0 ), \"distribution_t%construct: sample_distribution>=0.\" , & intrinsic_array_t ( sample_distribution )) associate ( nintervals => size ( sample_distribution , 1 )) distribution % vel_ = [( sample_distribution ( i , 1 ), i = 1 , nintervals )] ! Assign speeds to each distribution bin distribution % cumulative_distribution_ = [ 0.D0 , [( sum ( sample_distribution ( 1 : i , 2 )), i = 1 , nintervals )]] call assert ( monotonically_increasing ( distribution % cumulative_distribution_ ), & \"distribution_t: monotonically_increasing(distribution%cumulative_distribution_)\" , & intrinsic_array_t ( distribution % cumulative_distribution_ )) end associate end procedure construct module procedure cumulative_distribution call assert ( allocated ( self % cumulative_distribution_ ), & \"distribution_t%cumulative_distribution: allocated(cumulative_distribution_)\" ) my_cumulative_distribution = self % cumulative_distribution_ end procedure module procedure velocities double precision , allocatable :: sampled_speeds (:,:), dir (:,:,:) integer step call assert ( allocated ( self % cumulative_distribution_ ), & \"distribution_t%cumulative_distribution: allocated(cumulative_distribution_)\" ) call assert ( allocated ( self % vel_ ), \"distribution_t%cumulative_distribution: allocated(vel_)\" ) ! Sample from the distribution call do_concurrent_sampled_speeds ( speeds , self % vel_ , self % cumulative_distribution (), sampled_speeds ) associate ( nsteps => size ( speeds , 2 )) ! Create unit vectors dir = directions (:, 1 : nsteps ,:) associate ( dir_mag => sqrt ( dir (:,:, 1 ) ** 2 + dir (:,:, 2 ) ** 2 + dir (:,:, 3 ) ** 2 )) associate ( dir_mag_ => merge ( dir_mag , epsilon ( dir_mag ), dir_mag /= 0. )) dir (:,:, 1 ) = dir (:,:, 1 ) / dir_mag_ dir (:,:, 2 ) = dir (:,:, 2 ) / dir_mag_ dir (:,:, 3 ) = dir (:,:, 3 ) / dir_mag_ end associate end associate call do_concurrent_my_velocities ( nsteps , dir , sampled_speeds , my_velocities ) end associate end procedure end submodule distribution_s","tags":"","loc":"sourcefile/distribution_s.f90.html"},{"title":"do_concurrent_m.f90 – Matcha","text":"This file depends on sourcefile~~do_concurrent_m.f90~~EfferentGraph sourcefile~do_concurrent_m.f90 do_concurrent_m.f90 sourcefile~t_cell_collection_m.f90 t_cell_collection_m.f90 sourcefile~do_concurrent_m.f90->sourcefile~t_cell_collection_m.f90 sourcefile~distribution_m.f90 distribution_m.f90 sourcefile~t_cell_collection_m.f90->sourcefile~distribution_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~do_concurrent_m.f90~~AfferentGraph sourcefile~do_concurrent_m.f90 do_concurrent_m.f90 sourcefile~distribution_s.f90 distribution_s.F90 sourcefile~distribution_s.f90->sourcefile~do_concurrent_m.f90 sourcefile~do_concurrent_s.f90 do_concurrent_s.f90 sourcefile~do_concurrent_s.f90->sourcefile~do_concurrent_m.f90 sourcefile~output_s.f90 output_s.f90 sourcefile~output_s.f90->sourcefile~do_concurrent_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module do_concurrent_m use iso_c_binding , only : c_double , c_int use t_cell_collection_m , only : t_cell_collection_t , t_cell_collection_bind_C_t implicit none private public :: do_concurrent_sampled_speeds , do_concurrent_my_velocities , do_concurrent_k , do_concurrent_speeds public :: do_concurrent_output_distribution interface pure module subroutine do_concurrent_sampled_speeds ( speeds , vel , cumulative_distribution , sampled_speeds ) bind ( C ) implicit none real ( c_double ), intent ( in ) :: speeds (:,:), vel (:), cumulative_distribution (:) real ( c_double ), intent ( out ), allocatable :: sampled_speeds (:,:) end subroutine pure module subroutine do_concurrent_my_velocities ( nsteps , dir , sampled_speeds , my_velocities ) bind ( C ) implicit none integer ( c_int ), intent ( in ) :: nsteps real ( c_double ), intent ( in ) :: dir (:,:,:), sampled_speeds (:,:) real ( c_double ), intent ( out ), allocatable :: my_velocities (:,:,:) end subroutine pure module subroutine do_concurrent_k ( speeds , vel , k ) bind ( C ) implicit none real ( c_double ), intent ( in ) :: speeds (:), vel (:) integer ( c_int ), intent ( out ), allocatable :: k (:) end subroutine pure module subroutine & do_concurrent_output_distribution ( nintervals , speed , freq , emp_distribution , k , output_distribution ) bind ( C ) implicit none integer ( c_int ), intent ( in ) :: nintervals , speed , freq , k (:) real ( c_double ), intent ( in ) :: emp_distribution (:,:) real ( c_double ), intent ( out ), allocatable :: output_distribution (:,:) end subroutine module subroutine do_concurrent_speeds ( history , speeds ) bind ( C ) implicit none type ( t_cell_collection_bind_C_t ), intent ( in ) :: history (:) real ( c_double ), intent ( out ), allocatable :: speeds (:) end subroutine end interface end module do_concurrent_m","tags":"","loc":"sourcefile/do_concurrent_m.f90.html"},{"title":"output_m.f90 – Matcha","text":"This file depends on sourcefile~~output_m.f90~~EfferentGraph sourcefile~output_m.f90 output_m.f90 sourcefile~input_m.f90 input_m.f90 sourcefile~output_m.f90->sourcefile~input_m.f90 sourcefile~t_cell_collection_m.f90 t_cell_collection_m.f90 sourcefile~output_m.f90->sourcefile~t_cell_collection_m.f90 sourcefile~distribution_m.f90 distribution_m.f90 sourcefile~t_cell_collection_m.f90->sourcefile~distribution_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~output_m.f90~~AfferentGraph sourcefile~output_m.f90 output_m.f90 sourcefile~matcha_m.f90 matcha_m.f90 sourcefile~matcha_m.f90->sourcefile~output_m.f90 sourcefile~output_s.f90 output_s.f90 sourcefile~output_s.f90->sourcefile~output_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~matcha_m.f90 sourcefile~matcha_s.f90 matcha_s.F90 sourcefile~matcha_s.f90->sourcefile~matcha_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module output_m !! Output data abstraction use input_m , only : input_t use t_cell_collection_m , only : t_cell_collection_t implicit none private public :: output_t type output_t !! Encapsulate an input/result pair private type ( input_t ) input_ type ( t_cell_collection_t ), allocatable :: history_ (:) contains procedure :: simulated_distribution procedure :: my_num_cells end type interface output_t pure module function construct ( input , history ) result ( output ) !! Construct a new output_t object implicit none type ( input_t ), intent ( in ) :: input type ( t_cell_collection_t ), intent ( in ) :: history (:) type ( output_t ) :: output end function end interface interface module function simulated_distribution ( self ) result ( output_distribution ) !! The result is a histogram calculated from the simulation output implicit none class ( output_t ), intent ( in ) :: self double precision , allocatable :: output_distribution (:,:) end function pure module function my_num_cells ( self ) result ( num_cells ) implicit none class ( output_t ), intent ( in ) :: self integer num_cells end function end interface end module output_m","tags":"","loc":"sourcefile/output_m.f90.html"},{"title":"subdomain_m.f90 – Matcha","text":"Files dependent on this one sourcefile~~subdomain_m.f90~~AfferentGraph sourcefile~subdomain_m.f90 subdomain_m.f90 sourcefile~matcha_m.f90 matcha_m.f90 sourcefile~matcha_m.f90->sourcefile~subdomain_m.f90 sourcefile~subdomain_s.f90 subdomain_s.f90 sourcefile~subdomain_s.f90->sourcefile~subdomain_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~matcha_m.f90 sourcefile~matcha_s.f90 matcha_s.F90 sourcefile~matcha_s.f90->sourcefile~matcha_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module subdomain_m implicit none private public :: subdomain_t type subdomain_t private real , allocatable :: s_ (:,:,:) contains procedure , pass ( self ) :: define procedure , pass ( self ) :: step procedure , pass ( rhs ) :: multiply generic :: operator (. laplacian .) => laplacian generic :: operator ( * ) => multiply generic :: operator ( + ) => add generic :: assignment ( = ) => assign_and_sync procedure dt_stable procedure dx procedure dy procedure dz procedure values procedure , private :: laplacian procedure , private :: add procedure , private :: assign_and_sync end type interface module subroutine define ( side , boundary_val , internal_val , n , self ) implicit none real , intent ( in ) :: side , boundary_val , internal_val integer , intent ( in ) :: n !! number of grid points in each coordinate direction class ( subdomain_t ), intent ( out ) :: self end subroutine module subroutine step ( alpha_dt , self ) implicit none real , intent ( in ) :: alpha_dt class ( subdomain_t ), intent ( inout ) :: self end subroutine pure module function values ( self ) result ( my_values ) implicit none class ( subdomain_t ), intent ( in ) :: self real , allocatable :: my_values (:,:,:) end function pure module function dx ( self ) result ( my_dx ) implicit none class ( subdomain_t ), intent ( in ) :: self real my_dx end function pure module function dy ( self ) result ( my_dy ) implicit none class ( subdomain_t ), intent ( in ) :: self real my_dy end function pure module function dz ( self ) result ( my_dz ) implicit none class ( subdomain_t ), intent ( in ) :: self real my_dz end function pure module function dt_stable ( self , alpha ) result ( my_dt ) !! Set the time step at 90% of the stability limit obtained generalizing to 3D the value provided for 2D by !! Kassinos, S., & Alexiadis, A. (2024). Beyond Language: Applying MLX Transformers to Engineering Physics. !! arXiv preprint arXiv:2410.04167. implicit none class ( subdomain_t ), intent ( in ) :: self real , intent ( in ) :: alpha real my_dt end function pure module function laplacian ( rhs ) result ( laplacian_rhs ) implicit none class ( subdomain_t ), intent ( in ) :: rhs type ( subdomain_t ) laplacian_rhs end function pure module function multiply ( lhs , rhs ) result ( product ) implicit none class ( subdomain_t ), intent ( in ) :: rhs real , intent ( in ) :: lhs type ( subdomain_t ) product end function pure module function add ( lhs , rhs ) result ( total ) implicit none class ( subdomain_t ), intent ( in ) :: lhs type ( subdomain_t ), intent ( in ) :: rhs type ( subdomain_t ) total end function module subroutine assign_and_sync ( lhs , rhs ) implicit none class ( subdomain_t ), intent ( out ) :: lhs type ( subdomain_t ), intent ( in ) :: rhs end subroutine end interface end module","tags":"","loc":"sourcefile/subdomain_m.f90.html"},{"title":"input_m.f90 – Matcha","text":"Files dependent on this one sourcefile~~input_m.f90~~AfferentGraph sourcefile~input_m.f90 input_m.f90 sourcefile~input_s.f90 input_s.f90 sourcefile~input_s.f90->sourcefile~input_m.f90 sourcefile~matcha_m.f90 matcha_m.f90 sourcefile~matcha_m.f90->sourcefile~input_m.f90 sourcefile~output_m.f90 output_m.f90 sourcefile~matcha_m.f90->sourcefile~output_m.f90 sourcefile~output_m.f90->sourcefile~input_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~matcha_m.f90 sourcefile~matcha_s.f90 matcha_s.F90 sourcefile~matcha_s.f90->sourcefile~matcha_m.f90 sourcefile~output_s.f90 output_s.f90 sourcefile~output_s.f90->sourcefile~output_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module input_m implicit none private public :: input_t type input_t private integer :: num_cells_ = 6000 , num_positions_ = 6000 , num_dimensions_ = 3 , num_intervals_ = 4 double precision :: time_step_ = 0.1D0 !double precision, allocatable :: sample_distribution_(:,:) !allocate(sample_distribution_(num_intervals_,2)) contains procedure :: num_cells procedure :: num_positions procedure :: num_dimensions procedure :: num_intervals procedure :: time_step procedure :: sample_distribution end type interface pure module function num_cells ( self ) result ( n ) implicit none class ( input_t ), intent ( in ) :: self integer n end function pure module function num_positions ( self ) result ( n ) implicit none class ( input_t ), intent ( in ) :: self integer n end function pure module function num_dimensions ( self ) result ( n ) implicit none class ( input_t ), intent ( in ) :: self integer n end function pure module function num_intervals ( self ) result ( n ) implicit none class ( input_t ), intent ( in ) :: self integer n end function pure module function time_step ( self ) result ( dt ) implicit none class ( input_t ), intent ( in ) :: self double precision dt end function time_step pure module function sample_distribution ( self ) result ( empirical_distribution ) implicit none class ( input_t ), intent ( in ) :: self double precision , allocatable :: empirical_distribution (:,:) end function sample_distribution end interface end module input_m","tags":"","loc":"sourcefile/input_m.f90.html"},{"title":"output_s.f90 – Matcha","text":"This file depends on sourcefile~~output_s.f90~~EfferentGraph sourcefile~output_s.f90 output_s.f90 sourcefile~do_concurrent_m.f90 do_concurrent_m.f90 sourcefile~output_s.f90->sourcefile~do_concurrent_m.f90 sourcefile~output_m.f90 output_m.f90 sourcefile~output_s.f90->sourcefile~output_m.f90 sourcefile~t_cell_collection_m.f90 t_cell_collection_m.f90 sourcefile~output_s.f90->sourcefile~t_cell_collection_m.f90 sourcefile~do_concurrent_m.f90->sourcefile~t_cell_collection_m.f90 sourcefile~output_m.f90->sourcefile~t_cell_collection_m.f90 sourcefile~input_m.f90 input_m.f90 sourcefile~output_m.f90->sourcefile~input_m.f90 sourcefile~distribution_m.f90 distribution_m.f90 sourcefile~t_cell_collection_m.f90->sourcefile~distribution_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( output_m ) output_s use do_concurrent_m , only : do_concurrent_k , do_concurrent_output_distribution , do_concurrent_speeds use t_cell_collection_m , only : t_cell_collection_bind_C_t use iso_c_binding , only : c_loc , c_double implicit none contains module procedure construct output % input_ = input output % history_ = history end procedure module procedure my_num_cells num_cells = size ( self % history_ ( 1 )% positions (), 1 ) end procedure module procedure simulated_distribution integer i integer , allocatable :: k (:) real ( c_double ), allocatable , dimension (:) :: vel , speeds integer , parameter :: speed = 1 , freq = 2 ! subscripts for speeds and frequencies call do_concurrent_speeds ( t_cell_collection_bind_C_t ( self % history_ ), speeds ) associate ( emp_distribution => self % input_ % sample_distribution ()) associate ( nintervals => size ( emp_distribution (:, 1 )), dvel_half => ( emp_distribution ( 2 , speed ) - emp_distribution ( 1 , speed )) / 2.d0 ) vel = [ emp_distribution ( 1 , speed ) - dvel_half , [( emp_distribution ( i , speed ) + dvel_half , i = 1 , nintervals )]] call do_concurrent_k ( speeds , vel , k ) call do_concurrent_output_distribution ( nintervals , speed , freq , emp_distribution , k , output_distribution ) output_distribution (:, freq ) = output_distribution (:, freq ) / sum ( output_distribution (:, freq )) end associate end associate end procedure end submodule output_s","tags":"","loc":"sourcefile/output_s.f90.html"},{"title":"main.f90 – Matcha","text":"This file depends on sourcefile~~main.f90~~EfferentGraph sourcefile~main.f90 main.f90 sourcefile~matcha_m.f90 matcha_m.f90 sourcefile~main.f90->sourcefile~matcha_m.f90 sourcefile~distribution_m.f90 distribution_m.f90 sourcefile~matcha_m.f90->sourcefile~distribution_m.f90 sourcefile~input_m.f90 input_m.f90 sourcefile~matcha_m.f90->sourcefile~input_m.f90 sourcefile~output_m.f90 output_m.f90 sourcefile~matcha_m.f90->sourcefile~output_m.f90 sourcefile~subdomain_m.f90 subdomain_m.f90 sourcefile~matcha_m.f90->sourcefile~subdomain_m.f90 sourcefile~t_cell_collection_m.f90 t_cell_collection_m.f90 sourcefile~matcha_m.f90->sourcefile~t_cell_collection_m.f90 sourcefile~output_m.f90->sourcefile~input_m.f90 sourcefile~output_m.f90->sourcefile~t_cell_collection_m.f90 sourcefile~t_cell_collection_m.f90->sourcefile~distribution_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program main !! Matcha: Motility Analysis of T-Cell Histories in Activation use matcha_m , only : matcha , input_t , output_t implicit none type ( output_t ) output associate ( input => input_t ()) output = output_t ( input , matcha ( input )) block double precision , allocatable :: simulated_distribution (:,:) integer , parameter :: freq = 2 integer num_cells num_cells = output % my_num_cells () simulated_distribution = output % simulated_distribution () simulated_distribution (:, freq ) = num_cells * simulated_distribution (:, freq ) call co_sum ( simulated_distribution (:, freq ), result_image = 1 ) call co_sum ( num_cells , result_image = 1 ) if ( this_image () == 1 ) simulated_distribution (:, freq ) = simulated_distribution (:, freq ) / dble ( num_cells ) end block end associate print * print * , \"----> Matcha done. <----\" end program","tags":"","loc":"sourcefile/main.f90.html"}]}