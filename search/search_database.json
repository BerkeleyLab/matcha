var tipuesearch = {"pages":[{"title":" Matcha ","text":"Matcha","tags":"home","url":"index.html"},{"title":"input_t – Matcha ","text":"type, public :: input_t Inherited by type~~input_t~~InheritedByGraph type~input_t input_t type~output_t output_t type~output_t->type~input_t input_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer, private :: num_cells_ = 6000 integer, private :: num_positions_ = 6000 integer, private :: num_dimensions_ = 3 integer, private :: num_intervals_ = 4 double precision, private :: time_step_ = 0.1D0 Type-Bound Procedures procedure, public :: num_cells interface private pure module function num_cells(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer procedure, public :: num_positions interface private pure module function num_positions(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer procedure, public :: num_dimensions interface private pure module function num_dimensions(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer procedure, public :: num_intervals interface private pure module function num_intervals(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer procedure, public :: time_step interface private pure module function time_step(self) result(dt) Implementation → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value double precision procedure, public :: sample_distribution interface private pure module function sample_distribution(self) result(empirical_distribution) Implementation → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value double precision, allocatable, (:,:)","tags":"","url":"type/input_t.html"},{"title":"t_cell_collection_t – Matcha ","text":"type, public :: t_cell_collection_t Encapsulate the state of a collection of T cells Inherited by type~~t_cell_collection_t~~InheritedByGraph type~t_cell_collection_t t_cell_collection_t type~output_t output_t type~output_t->type~t_cell_collection_t history_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial double precision, private, allocatable :: positions_ (:,:) position vectors double precision, private :: time_ time stamp Constructor public        interface t_cell_collection_t private pure module function construct(positions, time) result(t_cell_collection) Implementation → Return a t_cell_collection_t object with rescaled position vectors and the provided time stamp Arguments Type Intent Optional Attributes Name double precision, intent(in) :: positions (:,:) double precision, intent(in) :: time Return Value type( t_cell_collection_t ) Type-Bound Procedures procedure, public :: positions interface private pure module function positions(self) result(my_positions) Implementation → Return the t_cell_collection_t object's position vectors Arguments Type Intent Optional Attributes Name class( t_cell_collection_t ), intent(in) :: self Return Value double precision, allocatable, (:,:) procedure, public :: time interface private elemental module function time(self) result(my_time) Implementation → Return the t_cell_collection_t object's time stamp Arguments Type Intent Optional Attributes Name class( t_cell_collection_t ), intent(in) :: self Return Value double precision","tags":"","url":"type/t_cell_collection_t.html"},{"title":"t_cell_collection_bind_C_t – Matcha ","text":"type, public, bind(C) :: t_cell_collection_bind_C_t Inherits type~~t_cell_collection_bind_c_t~~InheritsGraph type~t_cell_collection_bind_c_t t_cell_collection_bind_C_t c_ptr c_ptr type~t_cell_collection_bind_c_t->c_ptr positions_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type(c_ptr), public :: positions_ptr integer(kind=c_int), public :: positions_shape (positions_dimension) real(kind=c_double), public :: time Constructor public        interface t_cell_collection_bind_C_t private elemental module function construct_bind_C(t_cell_collection) result(t_cell_collection_bind_C) Implementation → Result is bind(C) representation of the data inside a t_cell_collection_t object Arguments Type Intent Optional Attributes Name type( t_cell_collection_t ), intent(in), target :: t_cell_collection Return Value type( t_cell_collection_bind_C_t )","tags":"","url":"type/t_cell_collection_bind_c_t.html"},{"title":"subdomain_t – Matcha ","text":"type, public :: subdomain_t Components Type Visibility Attributes Name Initial real, private, allocatable :: s_ (:,:,:) Type-Bound Procedures procedure, public, pass(self) :: define interface private module subroutine define(side, boundary_val, internal_val, n, self) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in) :: side real, intent(in) :: boundary_val real, intent(in) :: internal_val integer, intent(in) :: n number of grid points in each coordinate direction class( subdomain_t ), intent(out) :: self procedure, public, pass(self) :: step interface private module subroutine step(alpha_dt, self) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in) :: alpha_dt class( subdomain_t ), intent(inout) :: self procedure, public, pass(rhs) :: multiply interface private pure module function multiply(lhs, rhs) result(product) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in) :: lhs class( subdomain_t ), intent(in) :: rhs Return Value type( subdomain_t ) generic, public :: operator(.laplacian.) => laplacian private  interface laplacian () Arguments None generic, public :: operator(*) => multiply private  interface multiply () Arguments None generic, public :: operator(+) => add private  interface add () Arguments None generic, public :: assignment(=) => assign_and_sync private  interface assign_and_sync () Arguments None procedure, public :: dt_stable interface private pure module function dt_stable(self, alpha) result(my_dt) Implementation → Set the time step at 90% of the stability limit obtained generalizing to 3D the value provided for 2D by\nKassinos, S., & Alexiadis, A. (2024). Beyond Language: Applying MLX Transformers to Engineering Physics. \narXiv preprint arXiv:2410.04167. Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self real, intent(in) :: alpha Return Value real procedure, public :: dx interface private pure module function dx(self) result(my_dx) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real procedure, public :: dy interface private pure module function dy(self) result(my_dy) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real procedure, public :: dz interface private pure module function dz(self) result(my_dz) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real procedure, public :: values interface private pure module function values(self) result(my_values) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real, allocatable, (:,:,:) procedure, private :: laplacian interface private pure module function laplacian(rhs) result(laplacian_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: rhs Return Value type( subdomain_t ) procedure, private :: add interface private pure module function add(lhs, rhs) result(total) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: lhs type( subdomain_t ), intent(in) :: rhs Return Value type( subdomain_t ) procedure, private :: assign_and_sync interface private module subroutine assign_and_sync(lhs, rhs) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(out) :: lhs type( subdomain_t ), intent(in) :: rhs","tags":"","url":"type/subdomain_t.html"},{"title":"distribution_t – Matcha ","text":"type, public :: distribution_t Components Type Visibility Attributes Name Initial double precision, private, allocatable, dimension(:) :: vel_ double precision, private, allocatable, dimension(:) :: cumulative_distribution_ Constructor public        interface distribution_t private pure module function construct(sample_distribution) result(distribution) Implementation → Arguments Type Intent Optional Attributes Name double precision, intent(in) :: sample_distribution (:,:) Return Value type( distribution_t ) Type-Bound Procedures procedure, public :: cumulative_distribution interface private pure module function cumulative_distribution(self) result(my_cumulative_distribution) Implementation → Arguments Type Intent Optional Attributes Name class( distribution_t ), intent(in) :: self Return Value double precision, allocatable, (:) procedure, public :: velocities interface private pure module function velocities(self, speeds, directions) result(my_velocities) Implementation → Return the t_cell_collection_t object's velocity vectors Arguments Type Intent Optional Attributes Name class( distribution_t ), intent(in) :: self double precision, intent(in) :: speeds (:,:) double precision, intent(in) :: directions (:,:,:) Return Value double precision, allocatable, (:,:,:)","tags":"","url":"type/distribution_t.html"},{"title":"output_t – Matcha ","text":"type, public :: output_t Encapsulate an input/result pair Inherits type~~output_t~~InheritsGraph type~output_t output_t type~input_t input_t type~output_t->type~input_t input_ type~t_cell_collection_t t_cell_collection_t type~output_t->type~t_cell_collection_t history_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( input_t ), private :: input_ type( t_cell_collection_t ), private, allocatable :: history_ (:) Constructor public        interface output_t private pure module function construct(input, history) result(output) Implementation → Construct a new output_t object Arguments Type Intent Optional Attributes Name type( input_t ), intent(in) :: input type( t_cell_collection_t ), intent(in) :: history (:) Return Value type( output_t ) Type-Bound Procedures procedure, public :: simulated_distribution interface private pure module function simulated_distribution(self) result(output_distribution) Implementation → The result is a histogram calculated from the simulation output Arguments Type Intent Optional Attributes Name class( output_t ), intent(in) :: self Return Value double precision, allocatable, (:,:) procedure, public :: my_num_cells interface private pure module function my_num_cells(self) result(num_cells) Implementation → Arguments Type Intent Optional Attributes Name class( output_t ), intent(in) :: self Return Value integer","tags":"","url":"type/output_t.html"},{"title":"num_cells – Matcha","text":"interface Called by interface~~num_cells~~CalledByGraph interface~num_cells input_t%num_cells proc~matcha matcha proc~matcha->interface~num_cells Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private pure module function num_cells(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer","tags":"","url":"interface/num_cells.html"},{"title":"num_positions – Matcha","text":"interface Called by interface~~num_positions~~CalledByGraph interface~num_positions input_t%num_positions proc~matcha matcha proc~matcha->interface~num_positions Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private pure module function num_positions(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer","tags":"","url":"interface/num_positions.html"},{"title":"num_dimensions – Matcha","text":"interface Called by interface~~num_dimensions~~CalledByGraph interface~num_dimensions input_t%num_dimensions proc~matcha matcha proc~matcha->interface~num_dimensions Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private pure module function num_dimensions(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer","tags":"","url":"interface/num_dimensions.html"},{"title":"num_intervals – Matcha","text":"interface Called by interface~~num_intervals~~CalledByGraph interface~num_intervals input_t%num_intervals proc~matcha matcha proc~matcha->interface~num_intervals Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private pure module function num_intervals(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer","tags":"","url":"interface/num_intervals.html"},{"title":"time_step – Matcha","text":"interface Called by interface~~time_step~~CalledByGraph interface~time_step input_t%time_step proc~matcha matcha proc~matcha->interface~time_step Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private pure module function time_step(self) result(dt) Implementation → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value double precision","tags":"","url":"interface/time_step.html"},{"title":"sample_distribution – Matcha","text":"interface Called by interface~~sample_distribution~~CalledByGraph interface~sample_distribution input_t%sample_distribution proc~matcha matcha proc~matcha->interface~sample_distribution proc~simulated_distribution simulated_distribution proc~simulated_distribution->interface~sample_distribution Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private pure module function sample_distribution(self) result(empirical_distribution) Implementation → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value double precision,allocatable,(:,:)","tags":"","url":"interface/sample_distribution.html"},{"title":"matcha – Matcha","text":"interface Called by interface~~matcha~~CalledByGraph interface~matcha matcha program~main main program~main->interface~matcha Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public module function matcha(input) result(history) Implementation → Arguments Type Intent Optional Attributes Name type( input_t ), intent(in) :: input Return Value type( t_cell_collection_t ),allocatable,(:)","tags":"","url":"interface/matcha.html"},{"title":"t_cell_collection_t – Matcha","text":"public interface t_cell_collection_t Functions private pure module function construct(positions, time) result(t_cell_collection) Implementation → Return a t_cell_collection_t object with rescaled position vectors and the provided time stamp Arguments Type Intent Optional Attributes Name double precision, intent(in) :: positions (:,:) double precision, intent(in) :: time Return Value type( t_cell_collection_t )","tags":"","url":"interface/t_cell_collection_t.html"},{"title":"t_cell_collection_bind_C_t – Matcha","text":"public interface t_cell_collection_bind_C_t Functions private elemental module function construct_bind_C(t_cell_collection) result(t_cell_collection_bind_C) Implementation → Result is bind(C) representation of the data inside a t_cell_collection_t object Arguments Type Intent Optional Attributes Name type( t_cell_collection_t ), intent(in), target :: t_cell_collection Return Value type( t_cell_collection_bind_C_t )","tags":"","url":"interface/t_cell_collection_bind_c_t.html"},{"title":"positions – Matcha","text":"interface Called by interface~~positions~~CalledByGraph interface~positions t_cell_collection_t%positions proc~matcha matcha proc~matcha->interface~positions proc~my_num_cells my_num_cells proc~my_num_cells->interface~positions proc~simulated_distribution simulated_distribution proc~simulated_distribution->interface~positions Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private pure module function positions(self) result(my_positions) Implementation → Arguments Type Intent Optional Attributes Name class( t_cell_collection_t ), intent(in) :: self Return Value double precision,allocatable,(:,:) Description Return the t_cell_collection_t object's position vectors","tags":"","url":"interface/positions.html"},{"title":"time – Matcha","text":"interface private elemental module function time(self) result(my_time) Implementation → Arguments Type Intent Optional Attributes Name class( t_cell_collection_t ), intent(in) :: self Return Value double precision Description Return the t_cell_collection_t object's time stamp","tags":"","url":"interface/time.html"},{"title":"values – Matcha","text":"interface private pure module function values(self) result(my_values) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real,allocatable,(:,:,:)","tags":"","url":"interface/values.html"},{"title":"dx – Matcha","text":"interface private pure module function dx(self) result(my_dx) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real","tags":"","url":"interface/dx.html"},{"title":"dy – Matcha","text":"interface private pure module function dy(self) result(my_dy) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real","tags":"","url":"interface/dy.html"},{"title":"dz – Matcha","text":"interface private pure module function dz(self) result(my_dz) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real","tags":"","url":"interface/dz.html"},{"title":"dt_stable – Matcha","text":"interface Called by interface~~dt_stable~~CalledByGraph interface~dt_stable subdomain_t%dt_stable program~diffusion diffusion program~diffusion->interface~dt_stable Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private pure module function dt_stable(self, alpha) result(my_dt) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self real, intent(in) :: alpha Return Value real Description Set the time step at 90% of the stability limit obtained generalizing to 3D the value provided for 2D by\nKassinos, S., & Alexiadis, A. (2024). Beyond Language: Applying MLX Transformers to Engineering Physics. \narXiv preprint arXiv:2410.04167.","tags":"","url":"interface/dt_stable.html"},{"title":"laplacian – Matcha","text":"interface private pure module function laplacian(rhs) result(laplacian_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: rhs Return Value type( subdomain_t )","tags":"","url":"interface/laplacian.html"},{"title":"multiply – Matcha","text":"interface private pure module function multiply(lhs, rhs) result(product) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in) :: lhs class( subdomain_t ), intent(in) :: rhs Return Value type( subdomain_t )","tags":"","url":"interface/multiply.html"},{"title":"add – Matcha","text":"interface private pure module function add(lhs, rhs) result(total) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: lhs type( subdomain_t ), intent(in) :: rhs Return Value type( subdomain_t )","tags":"","url":"interface/add.html"},{"title":"define – Matcha","text":"interface Called by interface~~define~~CalledByGraph interface~define subdomain_t%define program~diffusion diffusion program~diffusion->interface~define Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private module subroutine define(side, boundary_val, internal_val, n, self) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in) :: side real, intent(in) :: boundary_val real, intent(in) :: internal_val integer, intent(in) :: n number of grid points in each coordinate direction class( subdomain_t ), intent(out) :: self","tags":"","url":"interface/define.html"},{"title":"step – Matcha","text":"interface private module subroutine step(alpha_dt, self) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in) :: alpha_dt class( subdomain_t ), intent(inout) :: self","tags":"","url":"interface/step.html"},{"title":"assign_and_sync – Matcha","text":"interface private module subroutine assign_and_sync(lhs, rhs) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(out) :: lhs type( subdomain_t ), intent(in) :: rhs","tags":"","url":"interface/assign_and_sync.html"},{"title":"monotonically_increasing – Matcha","text":"pure function monotonically_increasing(f) result(monotonic) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: f (:) Return Value logical Called by proc~~monotonically_increasing~~CalledByGraph proc~monotonically_increasing monotonically_increasing proc~construct construct proc~construct->proc~monotonically_increasing Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/monotonically_increasing.html"},{"title":"distribution_t – Matcha","text":"public interface distribution_t Functions private pure module function construct(sample_distribution) result(distribution) Implementation → Arguments Type Intent Optional Attributes Name double precision, intent(in) :: sample_distribution (:,:) Return Value type( distribution_t )","tags":"","url":"interface/distribution_t.html"},{"title":"cumulative_distribution – Matcha","text":"interface Called by interface~~cumulative_distribution~~CalledByGraph interface~cumulative_distribution distribution_t%cumulative_distribution proc~velocities velocities proc~velocities->interface~cumulative_distribution Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private pure module function cumulative_distribution(self) result(my_cumulative_distribution) Implementation → Arguments Type Intent Optional Attributes Name class( distribution_t ), intent(in) :: self Return Value double precision,allocatable,(:)","tags":"","url":"interface/cumulative_distribution.html"},{"title":"velocities – Matcha","text":"interface private pure module function velocities(self, speeds, directions) result(my_velocities) Implementation → Arguments Type Intent Optional Attributes Name class( distribution_t ), intent(in) :: self double precision, intent(in) :: speeds (:,:) double precision, intent(in) :: directions (:,:,:) Return Value double precision,allocatable,(:,:,:) Description Return the t_cell_collection_t object's velocity vectors","tags":"","url":"interface/velocities.html"},{"title":"output_t – Matcha","text":"public interface output_t Functions private pure module function construct(input, history) result(output) Implementation → Construct a new output_t object Arguments Type Intent Optional Attributes Name type( input_t ), intent(in) :: input type( t_cell_collection_t ), intent(in) :: history (:) Return Value type( output_t )","tags":"","url":"interface/output_t.html"},{"title":"simulated_distribution – Matcha","text":"interface private pure module function simulated_distribution(self) result(output_distribution) Implementation → Arguments Type Intent Optional Attributes Name class( output_t ), intent(in) :: self Return Value double precision,allocatable,(:,:) Description The result is a histogram calculated from the simulation output","tags":"","url":"interface/simulated_distribution.html"},{"title":"my_num_cells – Matcha","text":"interface Called by interface~~my_num_cells~~CalledByGraph interface~my_num_cells output_t%my_num_cells program~main main program~main->interface~my_num_cells Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private pure module function my_num_cells(self) result(num_cells) Implementation → Arguments Type Intent Optional Attributes Name class( output_t ), intent(in) :: self Return Value integer","tags":"","url":"interface/my_num_cells.html"},{"title":"dt_stable – Matcha","text":"module procedure dt_stable pure module function dt_stable(self, alpha) result(my_dt) Interface → Set the time step at 90% of the stability limit obtained generalizing to 3D the value provided for 2D by\nKassinos, S., & Alexiadis, A. (2024). Beyond Language: Applying MLX Transformers to Engineering Physics. \narXiv preprint arXiv:2410.04167. Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self real, intent(in) :: alpha Return Value real","tags":"","url":"proc/dt_stable.html"},{"title":"define – Matcha","text":"module procedure define module subroutine define(side, boundary_val, internal_val, n, self) Interface → Arguments Type Intent Optional Attributes Name real, intent(in) :: side real, intent(in) :: boundary_val real, intent(in) :: internal_val integer, intent(in) :: n number of grid points in each coordinate direction class( subdomain_t ), intent(out) :: self Calls proc~~define~~CallsGraph proc~define define bin_t bin_t proc~define->bin_t call_assert call_assert proc~define->call_assert first first proc~define->first last last proc~define->last Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/define.html"},{"title":"dx – Matcha","text":"module procedure dx pure module function dx(self) result(my_dx) Interface → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real","tags":"","url":"proc/dx.html"},{"title":"dy – Matcha","text":"module procedure dy pure module function dy(self) result(my_dy) Interface → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real","tags":"","url":"proc/dy.html"},{"title":"dz – Matcha","text":"module procedure dz pure module function dz(self) result(my_dz) Interface → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real","tags":"","url":"proc/dz.html"},{"title":"laplacian – Matcha","text":"module procedure laplacian pure module function laplacian(rhs) result(laplacian_rhs) Interface → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: rhs Return Value type( subdomain_t ) Calls proc~~laplacian~~CallsGraph proc~laplacian laplacian call_assert call_assert proc~laplacian->call_assert call_assert_describe call_assert_describe proc~laplacian->call_assert_describe default default proc~laplacian->default shared shared proc~laplacian->shared Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/laplacian.html"},{"title":"multiply – Matcha","text":"module procedure multiply pure module function multiply(lhs, rhs) result(product) Interface → Arguments Type Intent Optional Attributes Name real, intent(in) :: lhs class( subdomain_t ), intent(in) :: rhs Return Value type( subdomain_t ) Calls proc~~multiply~~CallsGraph proc~multiply multiply call_assert call_assert proc~multiply->call_assert Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/multiply.html"},{"title":"add – Matcha","text":"module procedure add pure module function add(lhs, rhs) result(total) Interface → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: lhs type( subdomain_t ), intent(in) :: rhs Return Value type( subdomain_t ) Calls proc~~add~~CallsGraph proc~add add call_assert call_assert proc~add->call_assert Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/add.html"},{"title":"assign_and_sync – Matcha","text":"module procedure assign_and_sync module subroutine assign_and_sync(lhs, rhs) Interface → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(out) :: lhs type( subdomain_t ), intent(in) :: rhs Calls proc~~assign_and_sync~~CallsGraph proc~assign_and_sync assign_and_sync call_assert call_assert proc~assign_and_sync->call_assert Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/assign_and_sync.html"},{"title":"values – Matcha","text":"module procedure values pure module function values(self) result(my_values) Interface → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real, allocatable, (:,:,:) Calls proc~~values~~CallsGraph proc~values values call_assert call_assert proc~values->call_assert Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/values.html"},{"title":"step – Matcha","text":"module procedure step module subroutine step(alpha_dt, self) Interface → Arguments Type Intent Optional Attributes Name real, intent(in) :: alpha_dt class( subdomain_t ), intent(inout) :: self Calls proc~~step~~CallsGraph proc~step step call_assert call_assert proc~step->call_assert call_assert_describe call_assert_describe proc~step->call_assert_describe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/step.html"},{"title":"construct – Matcha","text":"module procedure construct pure module function construct(sample_distribution) result(distribution) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: sample_distribution (:,:) Return Value type( distribution_t ) Calls proc~~construct~~CallsGraph proc~construct construct call_assert call_assert proc~construct->call_assert proc~monotonically_increasing monotonically_increasing proc~construct->proc~monotonically_increasing Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/construct.html"},{"title":"cumulative_distribution – Matcha","text":"module procedure cumulative_distribution pure module function cumulative_distribution(self) result(my_cumulative_distribution) Interface → Arguments Type Intent Optional Attributes Name class( distribution_t ), intent(in) :: self Return Value double precision, allocatable, (:) Calls proc~~cumulative_distribution~~CallsGraph proc~cumulative_distribution cumulative_distribution call_assert call_assert proc~cumulative_distribution->call_assert Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/cumulative_distribution.html"},{"title":"velocities – Matcha","text":"module procedure velocities pure module function velocities(self, speeds, directions) result(my_velocities) Interface → Arguments Type Intent Optional Attributes Name class( distribution_t ), intent(in) :: self double precision, intent(in) :: speeds (:,:) double precision, intent(in) :: directions (:,:,:) Return Value double precision, allocatable, (:,:,:) Calls proc~~velocities~~CallsGraph proc~velocities velocities call_assert call_assert proc~velocities->call_assert interface~cumulative_distribution distribution_t%cumulative_distribution proc~velocities->interface~cumulative_distribution Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/velocities.html"},{"title":"construct – Matcha","text":"module procedure construct pure module function construct(positions, time) result(t_cell_collection) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: positions (:,:) double precision, intent(in) :: time Return Value type( t_cell_collection_t )","tags":"","url":"proc/construct~2.html"},{"title":"positions – Matcha","text":"module procedure positions pure module function positions(self) result(my_positions) Interface → Arguments Type Intent Optional Attributes Name class( t_cell_collection_t ), intent(in) :: self Return Value double precision, allocatable, (:,:) Calls proc~~positions~~CallsGraph proc~positions positions call_assert call_assert proc~positions->call_assert Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/positions.html"},{"title":"time – Matcha","text":"module procedure time elemental module function time(self) result(my_time) Interface → Arguments Type Intent Optional Attributes Name class( t_cell_collection_t ), intent(in) :: self Return Value double precision","tags":"","url":"proc/time.html"},{"title":"construct_bind_C – Matcha","text":"module procedure construct_bind_C elemental module function construct_bind_C(t_cell_collection) result(t_cell_collection_bind_C) Arguments Type Intent Optional Attributes Name type( t_cell_collection_t ), intent(in), target :: t_cell_collection Return Value type( t_cell_collection_bind_C_t )","tags":"","url":"proc/construct_bind_c.html"},{"title":"num_cells – Matcha","text":"module procedure num_cells pure module function num_cells(self) result(n) Interface → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer","tags":"","url":"proc/num_cells.html"},{"title":"num_positions – Matcha","text":"module procedure num_positions pure module function num_positions(self) result(n) Interface → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer","tags":"","url":"proc/num_positions.html"},{"title":"num_dimensions – Matcha","text":"module procedure num_dimensions pure module function num_dimensions(self) result(n) Interface → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer","tags":"","url":"proc/num_dimensions.html"},{"title":"num_intervals – Matcha","text":"module procedure num_intervals pure module function num_intervals(self) result(n) Interface → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer","tags":"","url":"proc/num_intervals.html"},{"title":"time_step – Matcha","text":"module procedure time_step pure module function time_step(self) result(dt) Interface → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value double precision","tags":"","url":"proc/time_step.html"},{"title":"sample_distribution – Matcha","text":"module procedure sample_distribution pure module function sample_distribution(self) result(empirical_distribution) Interface → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value double precision, allocatable, (:,:)","tags":"","url":"proc/sample_distribution.html"},{"title":"construct – Matcha","text":"module procedure construct pure module function construct(input, history) result(output) Arguments Type Intent Optional Attributes Name type( input_t ), intent(in) :: input type( t_cell_collection_t ), intent(in) :: history (:) Return Value type( output_t )","tags":"","url":"proc/construct~3.html"},{"title":"my_num_cells – Matcha","text":"module procedure my_num_cells pure module function my_num_cells(self) result(num_cells) Interface → Arguments Type Intent Optional Attributes Name class( output_t ), intent(in) :: self Return Value integer Calls proc~~my_num_cells~~CallsGraph proc~my_num_cells my_num_cells interface~positions t_cell_collection_t%positions proc~my_num_cells->interface~positions Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/my_num_cells.html"},{"title":"simulated_distribution – Matcha","text":"module procedure simulated_distribution pure module function simulated_distribution(self) result(output_distribution) Interface → Arguments Type Intent Optional Attributes Name class( output_t ), intent(in) :: self Return Value double precision, allocatable, (:,:) Calls proc~~simulated_distribution~~CallsGraph proc~simulated_distribution simulated_distribution interface~positions t_cell_collection_t%positions proc~simulated_distribution->interface~positions interface~sample_distribution input_t%sample_distribution proc~simulated_distribution->interface~sample_distribution Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/simulated_distribution.html"},{"title":"matcha – Matcha","text":"module procedure matcha module function matcha(input) result(history) Interface → Arguments Type Intent Optional Attributes Name type( input_t ), intent(in) :: input Return Value type( t_cell_collection_t ), allocatable, (:) Calls proc~~matcha~~CallsGraph proc~matcha matcha bin_t bin_t proc~matcha->bin_t first first proc~matcha->first interface~num_cells input_t%num_cells proc~matcha->interface~num_cells interface~num_dimensions input_t%num_dimensions proc~matcha->interface~num_dimensions interface~num_intervals input_t%num_intervals proc~matcha->interface~num_intervals interface~num_positions input_t%num_positions proc~matcha->interface~num_positions interface~positions t_cell_collection_t%positions proc~matcha->interface~positions interface~sample_distribution input_t%sample_distribution proc~matcha->interface~sample_distribution interface~time_step input_t%time_step proc~matcha->interface~time_step last last proc~matcha->last random_4vectors random_4vectors proc~matcha->random_4vectors random_init random_init proc~matcha->random_init random_positions random_positions proc~matcha->random_positions velocities velocities proc~matcha->velocities Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/matcha.html"},{"title":"input_m – Matcha","text":"Used by Descendants: input_s module~~input_m~~UsedByGraph module~input_m input_m module~input_s input_s module~input_s->module~input_m module~matcha_m matcha_m module~matcha_m->module~input_m module~output_m output_m module~matcha_m->module~output_m module~output_m->module~input_m module~matcha_s matcha_s module~matcha_s->module~matcha_m module~output_s output_s module~output_s->module~output_m program~diffusion diffusion program~diffusion->module~matcha_m program~main main program~main->module~matcha_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces interface private pure module function num_cells(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer interface private pure module function num_positions(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer interface private pure module function num_dimensions(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer interface private pure module function num_intervals(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer interface private pure module function time_step(self) result(dt) Implementation → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value double precision interface private pure module function sample_distribution(self) result(empirical_distribution) Implementation → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value double precision, allocatable, (:,:) Derived Types type, public :: input_t Components Type Visibility Attributes Name Initial integer, private :: num_cells_ = 6000 integer, private :: num_positions_ = 6000 integer, private :: num_dimensions_ = 3 integer, private :: num_intervals_ = 4 double precision, private :: time_step_ = 0.1D0 Type-Bound Procedures procedure, public :: num_cells procedure, public :: num_positions procedure, public :: num_dimensions procedure, public :: num_intervals procedure, public :: time_step procedure, public :: sample_distribution","tags":"","url":"module/input_m.html"},{"title":"matcha_m – Matcha","text":"Uses t_cell_collection_m output_m input_m distribution_m subdomain_m module~~matcha_m~~UsesGraph module~matcha_m matcha_m module~distribution_m distribution_m module~matcha_m->module~distribution_m module~input_m input_m module~matcha_m->module~input_m module~output_m output_m module~matcha_m->module~output_m module~subdomain_m subdomain_m module~matcha_m->module~subdomain_m module~t_cell_collection_m t_cell_collection_m module~matcha_m->module~t_cell_collection_m module~output_m->module~input_m module~output_m->module~t_cell_collection_m module~t_cell_collection_m->module~distribution_m iso_c_binding iso_c_binding module~t_cell_collection_m->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by Descendants: matcha_s module~~matcha_m~~UsedByGraph module~matcha_m matcha_m module~matcha_s matcha_s module~matcha_s->module~matcha_m program~diffusion diffusion program~diffusion->module~matcha_m program~main main program~main->module~matcha_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces interface public module function matcha(input) result(history) Implementation → Arguments Type Intent Optional Attributes Name type( input_t ), intent(in) :: input Return Value type( t_cell_collection_t ), allocatable, (:)","tags":"","url":"module/matcha_m.html"},{"title":"t_cell_collection_m – Matcha","text":"Define a T-cell abstraction for motility simulations Uses iso_c_binding distribution_m module~~t_cell_collection_m~~UsesGraph module~t_cell_collection_m t_cell_collection_m iso_c_binding iso_c_binding module~t_cell_collection_m->iso_c_binding module~distribution_m distribution_m module~t_cell_collection_m->module~distribution_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by Descendants: t_cell_collection_s module~~t_cell_collection_m~~UsedByGraph module~t_cell_collection_m t_cell_collection_m module~matcha_m matcha_m module~matcha_m->module~t_cell_collection_m module~output_m output_m module~matcha_m->module~output_m module~matcha_s matcha_s module~matcha_s->module~t_cell_collection_m module~matcha_s->module~matcha_m module~output_m->module~t_cell_collection_m module~t_cell_collection_s t_cell_collection_s module~t_cell_collection_s->module~t_cell_collection_m module~output_s output_s module~output_s->module~output_m program~diffusion diffusion program~diffusion->module~matcha_m program~main main program~main->module~matcha_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, private, parameter :: positions_dimension = 2 Interfaces public        interface t_cell_collection_t private pure module function construct(positions, time) result(t_cell_collection) Implementation → Return a t_cell_collection_t object with rescaled position vectors and the provided time stamp Arguments Type Intent Optional Attributes Name double precision, intent(in) :: positions (:,:) double precision, intent(in) :: time Return Value type( t_cell_collection_t ) public        interface t_cell_collection_bind_C_t private elemental module function construct_bind_C(t_cell_collection) result(t_cell_collection_bind_C) Implementation → Result is bind(C) representation of the data inside a t_cell_collection_t object Arguments Type Intent Optional Attributes Name type( t_cell_collection_t ), intent(in), target :: t_cell_collection Return Value type( t_cell_collection_bind_C_t ) interface private pure module function positions(self) result(my_positions) Implementation → Return the t_cell_collection_t object's position vectors Arguments Type Intent Optional Attributes Name class( t_cell_collection_t ), intent(in) :: self Return Value double precision, allocatable, (:,:) interface private elemental module function time(self) result(my_time) Implementation → Return the t_cell_collection_t object's time stamp Arguments Type Intent Optional Attributes Name class( t_cell_collection_t ), intent(in) :: self Return Value double precision Derived Types type, public :: t_cell_collection_t Encapsulate the state of a collection of T cells Components Type Visibility Attributes Name Initial double precision, private, allocatable :: positions_ (:,:) position vectors double precision, private :: time_ time stamp Constructor private\n\n                    pure, module\n                    function construct (positions, time) Return a t_cell_collection_t object with rescaled position vectors and the provided time stamp Type-Bound Procedures procedure, public :: positions procedure, public :: time type, public, bind(C) :: t_cell_collection_bind_C_t Components Type Visibility Attributes Name Initial type(c_ptr), public :: positions_ptr integer(kind=c_int), public :: positions_shape (positions_dimension) real(kind=c_double), public :: time Constructor private\n\n                    elemental, module\n                    function construct_bind_C (t_cell_collection) Result is bind(C) representation of the data inside a t_cell_collection_t object","tags":"","url":"module/t_cell_collection_m.html"},{"title":"subdomain_m – Matcha","text":"Used by Descendants: subdomain_s module~~subdomain_m~~UsedByGraph module~subdomain_m subdomain_m module~matcha_m matcha_m module~matcha_m->module~subdomain_m module~subdomain_s subdomain_s module~subdomain_s->module~subdomain_m module~matcha_s matcha_s module~matcha_s->module~matcha_m program~diffusion diffusion program~diffusion->module~matcha_m program~main main program~main->module~matcha_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces interface private pure module function values(self) result(my_values) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real, allocatable, (:,:,:) interface private pure module function dx(self) result(my_dx) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real interface private pure module function dy(self) result(my_dy) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real interface private pure module function dz(self) result(my_dz) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real interface private pure module function dt_stable(self, alpha) result(my_dt) Implementation → Set the time step at 90% of the stability limit obtained generalizing to 3D the value provided for 2D by\nKassinos, S., & Alexiadis, A. (2024). Beyond Language: Applying MLX Transformers to Engineering Physics. \narXiv preprint arXiv:2410.04167. Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self real, intent(in) :: alpha Return Value real interface private pure module function laplacian(rhs) result(laplacian_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: rhs Return Value type( subdomain_t ) interface private pure module function multiply(lhs, rhs) result(product) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in) :: lhs class( subdomain_t ), intent(in) :: rhs Return Value type( subdomain_t ) interface private pure module function add(lhs, rhs) result(total) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: lhs type( subdomain_t ), intent(in) :: rhs Return Value type( subdomain_t ) interface private module subroutine define(side, boundary_val, internal_val, n, self) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in) :: side real, intent(in) :: boundary_val real, intent(in) :: internal_val integer, intent(in) :: n number of grid points in each coordinate direction class( subdomain_t ), intent(out) :: self interface private module subroutine step(alpha_dt, self) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in) :: alpha_dt class( subdomain_t ), intent(inout) :: self interface private module subroutine assign_and_sync(lhs, rhs) Implementation → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(out) :: lhs type( subdomain_t ), intent(in) :: rhs Derived Types type, public :: subdomain_t Components Type Visibility Attributes Name Initial real, private, allocatable :: s_ (:,:,:) Type-Bound Procedures procedure, public, pass(self) :: define procedure, public, pass(self) :: step procedure, public, pass(rhs) :: multiply generic, public :: operator(.laplacian.) => laplacian generic, public :: operator(*) => multiply generic, public :: operator(+) => add generic, public :: assignment(=) => assign_and_sync procedure, public :: dt_stable procedure, public :: dx procedure, public :: dy procedure, public :: dz procedure, public :: values procedure, private :: laplacian procedure, private :: add procedure, private :: assign_and_sync","tags":"","url":"module/subdomain_m.html"},{"title":"distribution_m – Matcha","text":"Used by Descendants: distribution_s module~~distribution_m~~UsedByGraph module~distribution_m distribution_m module~distribution_s distribution_s module~distribution_s->module~distribution_m module~matcha_m matcha_m module~matcha_m->module~distribution_m module~t_cell_collection_m t_cell_collection_m module~matcha_m->module~t_cell_collection_m module~output_m output_m module~matcha_m->module~output_m module~matcha_s matcha_s module~matcha_s->module~distribution_m module~matcha_s->module~matcha_m module~matcha_s->module~t_cell_collection_m module~t_cell_collection_m->module~distribution_m module~output_m->module~t_cell_collection_m module~t_cell_collection_s t_cell_collection_s module~t_cell_collection_s->module~t_cell_collection_m program~diffusion diffusion program~diffusion->module~matcha_m program~main main program~main->module~matcha_m module~output_s output_s module~output_s->module~output_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface distribution_t private pure module function construct(sample_distribution) result(distribution) Implementation → Arguments Type Intent Optional Attributes Name double precision, intent(in) :: sample_distribution (:,:) Return Value type( distribution_t ) interface private pure module function cumulative_distribution(self) result(my_cumulative_distribution) Implementation → Arguments Type Intent Optional Attributes Name class( distribution_t ), intent(in) :: self Return Value double precision, allocatable, (:) interface private pure module function velocities(self, speeds, directions) result(my_velocities) Implementation → Return the t_cell_collection_t object's velocity vectors Arguments Type Intent Optional Attributes Name class( distribution_t ), intent(in) :: self double precision, intent(in) :: speeds (:,:) double precision, intent(in) :: directions (:,:,:) Return Value double precision, allocatable, (:,:,:) Derived Types type, public :: distribution_t Components Type Visibility Attributes Name Initial double precision, private, allocatable, dimension(:) :: vel_ double precision, private, allocatable, dimension(:) :: cumulative_distribution_ Constructor private\n\n                    pure, module\n                    function construct (sample_distribution) Type-Bound Procedures procedure, public :: cumulative_distribution procedure, public :: velocities","tags":"","url":"module/distribution_m.html"},{"title":"output_m – Matcha","text":"Output data abstraction Uses t_cell_collection_m input_m module~~output_m~~UsesGraph module~output_m output_m module~input_m input_m module~output_m->module~input_m module~t_cell_collection_m t_cell_collection_m module~output_m->module~t_cell_collection_m iso_c_binding iso_c_binding module~t_cell_collection_m->iso_c_binding module~distribution_m distribution_m module~t_cell_collection_m->module~distribution_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by Descendants: output_s module~~output_m~~UsedByGraph module~output_m output_m module~matcha_m matcha_m module~matcha_m->module~output_m module~output_s output_s module~output_s->module~output_m module~matcha_s matcha_s module~matcha_s->module~matcha_m program~diffusion diffusion program~diffusion->module~matcha_m program~main main program~main->module~matcha_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface output_t private pure module function construct(input, history) result(output) Implementation → Construct a new output_t object Arguments Type Intent Optional Attributes Name type( input_t ), intent(in) :: input type( t_cell_collection_t ), intent(in) :: history (:) Return Value type( output_t ) interface private pure module function simulated_distribution(self) result(output_distribution) Implementation → The result is a histogram calculated from the simulation output Arguments Type Intent Optional Attributes Name class( output_t ), intent(in) :: self Return Value double precision, allocatable, (:,:) interface private pure module function my_num_cells(self) result(num_cells) Implementation → Arguments Type Intent Optional Attributes Name class( output_t ), intent(in) :: self Return Value integer Derived Types type, public :: output_t Encapsulate an input/result pair Components Type Visibility Attributes Name Initial type( input_t ), private :: input_ type( t_cell_collection_t ), private, allocatable :: history_ (:) Constructor private\n\n                    pure, module\n                    function construct (input, history) Construct a new output_t object Type-Bound Procedures procedure, public :: simulated_distribution procedure, public :: my_num_cells","tags":"","url":"module/output_m.html"},{"title":"subdomain_s – Matcha","text":"Uses assert_m julienne_m Ancestors: subdomain_m module~~subdomain_s~~UsesGraph module~subdomain_s subdomain_s assert_m assert_m module~subdomain_s->assert_m julienne_m julienne_m module~subdomain_s->julienne_m module~subdomain_m subdomain_m module~subdomain_s->module~subdomain_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial real, private, allocatable :: halo_x (:,:,:)[:] integer, private, parameter :: west = 1 integer, private, parameter :: east = 2 real, private :: dx_ real, private :: dy_ real, private :: dz_ integer, private :: my_nx integer, private :: nx integer, private :: ny integer, private :: nz integer, private :: me integer, private :: num_subdomains integer, private :: my_internal_west integer, private :: my_internal_east real, private, allocatable :: increment (:,:,:) Module Procedures module procedure /home/runner/work/matcha/matcha/doc/html/module/subdomain_s.html dt_stable pure module function dt_stable(self, alpha) result(my_dt) Interface → Set the time step at 90% of the stability limit obtained generalizing to 3D the value provided for 2D by\nKassinos, S., & Alexiadis, A. (2024). Beyond Language: Applying MLX Transformers to Engineering Physics. \narXiv preprint arXiv:2410.04167. Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self real, intent(in) :: alpha Return Value real module procedure /home/runner/work/matcha/matcha/doc/html/module/subdomain_s.html define module subroutine define(side, boundary_val, internal_val, n, self) Interface → Arguments Type Intent Optional Attributes Name real, intent(in) :: side real, intent(in) :: boundary_val real, intent(in) :: internal_val integer, intent(in) :: n number of grid points in each coordinate direction class( subdomain_t ), intent(out) :: self module procedure /home/runner/work/matcha/matcha/doc/html/module/subdomain_s.html dx pure module function dx(self) result(my_dx) Interface → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real module procedure /home/runner/work/matcha/matcha/doc/html/module/subdomain_s.html dy pure module function dy(self) result(my_dy) Interface → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real module procedure /home/runner/work/matcha/matcha/doc/html/module/subdomain_s.html dz pure module function dz(self) result(my_dz) Interface → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real module procedure /home/runner/work/matcha/matcha/doc/html/module/subdomain_s.html laplacian pure module function laplacian(rhs) result(laplacian_rhs) Interface → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: rhs Return Value type( subdomain_t ) module procedure /home/runner/work/matcha/matcha/doc/html/module/subdomain_s.html multiply pure module function multiply(lhs, rhs) result(product) Interface → Arguments Type Intent Optional Attributes Name real, intent(in) :: lhs class( subdomain_t ), intent(in) :: rhs Return Value type( subdomain_t ) module procedure /home/runner/work/matcha/matcha/doc/html/module/subdomain_s.html add pure module function add(lhs, rhs) result(total) Interface → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: lhs type( subdomain_t ), intent(in) :: rhs Return Value type( subdomain_t ) module procedure /home/runner/work/matcha/matcha/doc/html/module/subdomain_s.html assign_and_sync module subroutine assign_and_sync(lhs, rhs) Interface → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(out) :: lhs type( subdomain_t ), intent(in) :: rhs module procedure /home/runner/work/matcha/matcha/doc/html/module/subdomain_s.html values pure module function values(self) result(my_values) Interface → Arguments Type Intent Optional Attributes Name class( subdomain_t ), intent(in) :: self Return Value real, allocatable, (:,:,:) module procedure /home/runner/work/matcha/matcha/doc/html/module/subdomain_s.html step module subroutine step(alpha_dt, self) Interface → Arguments Type Intent Optional Attributes Name real, intent(in) :: alpha_dt class( subdomain_t ), intent(inout) :: self","tags":"","url":"module/subdomain_s.html"},{"title":"distribution_s – Matcha","text":"Uses assert_m Ancestors: distribution_m module~~distribution_s~~UsesGraph module~distribution_s distribution_s assert_m assert_m module~distribution_s->assert_m module~distribution_m distribution_m module~distribution_s->module~distribution_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Functions pure function monotonically_increasing (f) result(monotonic) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: f (:) Return Value logical Module Procedures module procedure /home/runner/work/matcha/matcha/doc/html/module/distribution_s.html construct pure module function construct(sample_distribution) result(distribution) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: sample_distribution (:,:) Return Value type( distribution_t ) module procedure /home/runner/work/matcha/matcha/doc/html/module/distribution_s.html cumulative_distribution pure module function cumulative_distribution(self) result(my_cumulative_distribution) Interface → Arguments Type Intent Optional Attributes Name class( distribution_t ), intent(in) :: self Return Value double precision, allocatable, (:) module procedure /home/runner/work/matcha/matcha/doc/html/module/distribution_s.html velocities pure module function velocities(self, speeds, directions) result(my_velocities) Interface → Arguments Type Intent Optional Attributes Name class( distribution_t ), intent(in) :: self double precision, intent(in) :: speeds (:,:) double precision, intent(in) :: directions (:,:,:) Return Value double precision, allocatable, (:,:,:)","tags":"","url":"module/distribution_s.html"},{"title":"t_cell_collection_s – Matcha","text":"Uses iso_c_binding assert_m Ancestors: t_cell_collection_m module~~t_cell_collection_s~~UsesGraph module~t_cell_collection_s t_cell_collection_s assert_m assert_m module~t_cell_collection_s->assert_m iso_c_binding iso_c_binding module~t_cell_collection_s->iso_c_binding module~t_cell_collection_m t_cell_collection_m module~t_cell_collection_s->module~t_cell_collection_m module~t_cell_collection_m->iso_c_binding module~distribution_m distribution_m module~t_cell_collection_m->module~distribution_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Module Procedures module procedure /home/runner/work/matcha/matcha/doc/html/module/t_cell_collection_s.html construct pure module function construct(positions, time) result(t_cell_collection) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: positions (:,:) double precision, intent(in) :: time Return Value type( t_cell_collection_t ) module procedure /home/runner/work/matcha/matcha/doc/html/module/t_cell_collection_s.html positions pure module function positions(self) result(my_positions) Interface → Arguments Type Intent Optional Attributes Name class( t_cell_collection_t ), intent(in) :: self Return Value double precision, allocatable, (:,:) module procedure /home/runner/work/matcha/matcha/doc/html/module/t_cell_collection_s.html time elemental module function time(self) result(my_time) Interface → Arguments Type Intent Optional Attributes Name class( t_cell_collection_t ), intent(in) :: self Return Value double precision module procedure /home/runner/work/matcha/matcha/doc/html/module/t_cell_collection_s.html construct_bind_C elemental module function construct_bind_C(t_cell_collection) result(t_cell_collection_bind_C) Arguments Type Intent Optional Attributes Name type( t_cell_collection_t ), intent(in), target :: t_cell_collection Return Value type( t_cell_collection_bind_C_t )","tags":"","url":"module/t_cell_collection_s.html"},{"title":"input_s – Matcha","text":"Uses Ancestors: input_m module~~input_s~~UsesGraph module~input_s input_s module~input_m input_m module~input_s->module~input_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Module Procedures module procedure /home/runner/work/matcha/matcha/doc/html/module/input_s.html num_cells pure module function num_cells(self) result(n) Interface → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer module procedure /home/runner/work/matcha/matcha/doc/html/module/input_s.html num_positions pure module function num_positions(self) result(n) Interface → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer module procedure /home/runner/work/matcha/matcha/doc/html/module/input_s.html num_dimensions pure module function num_dimensions(self) result(n) Interface → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer module procedure /home/runner/work/matcha/matcha/doc/html/module/input_s.html num_intervals pure module function num_intervals(self) result(n) Interface → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value integer module procedure /home/runner/work/matcha/matcha/doc/html/module/input_s.html time_step pure module function time_step(self) result(dt) Interface → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value double precision module procedure /home/runner/work/matcha/matcha/doc/html/module/input_s.html sample_distribution pure module function sample_distribution(self) result(empirical_distribution) Interface → Arguments Type Intent Optional Attributes Name class( input_t ), intent(in) :: self Return Value double precision, allocatable, (:,:)","tags":"","url":"module/input_s.html"},{"title":"output_s – Matcha","text":"Uses Ancestors: output_m module~~output_s~~UsesGraph module~output_s output_s module~output_m output_m module~output_s->module~output_m module~input_m input_m module~output_m->module~input_m module~t_cell_collection_m t_cell_collection_m module~output_m->module~t_cell_collection_m iso_c_binding iso_c_binding module~t_cell_collection_m->iso_c_binding module~distribution_m distribution_m module~t_cell_collection_m->module~distribution_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Module Procedures module procedure /home/runner/work/matcha/matcha/doc/html/module/output_s.html construct pure module function construct(input, history) result(output) Arguments Type Intent Optional Attributes Name type( input_t ), intent(in) :: input type( t_cell_collection_t ), intent(in) :: history (:) Return Value type( output_t ) module procedure /home/runner/work/matcha/matcha/doc/html/module/output_s.html my_num_cells pure module function my_num_cells(self) result(num_cells) Interface → Arguments Type Intent Optional Attributes Name class( output_t ), intent(in) :: self Return Value integer module procedure /home/runner/work/matcha/matcha/doc/html/module/output_s.html simulated_distribution pure module function simulated_distribution(self) result(output_distribution) Interface → Arguments Type Intent Optional Attributes Name class( output_t ), intent(in) :: self Return Value double precision, allocatable, (:,:)","tags":"","url":"module/output_s.html"},{"title":"matcha_s – Matcha","text":"Uses t_cell_collection_m julienne_m distribution_m Ancestors: matcha_m module~~matcha_s~~UsesGraph module~matcha_s matcha_s julienne_m julienne_m module~matcha_s->julienne_m module~distribution_m distribution_m module~matcha_s->module~distribution_m module~matcha_m matcha_m module~matcha_s->module~matcha_m module~t_cell_collection_m t_cell_collection_m module~matcha_s->module~t_cell_collection_m module~matcha_m->module~distribution_m module~matcha_m->module~t_cell_collection_m module~input_m input_m module~matcha_m->module~input_m module~output_m output_m module~matcha_m->module~output_m module~subdomain_m subdomain_m module~matcha_m->module~subdomain_m module~t_cell_collection_m->module~distribution_m iso_c_binding iso_c_binding module~t_cell_collection_m->iso_c_binding module~output_m->module~t_cell_collection_m module~output_m->module~input_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Module Procedures module procedure /home/runner/work/matcha/matcha/doc/html/module/matcha_s.html matcha module function matcha(input) result(history) Interface → Arguments Type Intent Optional Attributes Name type( input_t ), intent(in) :: input Return Value type( t_cell_collection_t ), allocatable, (:)","tags":"","url":"module/matcha_s.html"},{"title":"diffusion – Matcha","text":"Uses matcha_m program~~diffusion~~UsesGraph program~diffusion diffusion module~matcha_m matcha_m program~diffusion->module~matcha_m module~distribution_m distribution_m module~matcha_m->module~distribution_m module~input_m input_m module~matcha_m->module~input_m module~output_m output_m module~matcha_m->module~output_m module~subdomain_m subdomain_m module~matcha_m->module~subdomain_m module~t_cell_collection_m t_cell_collection_m module~matcha_m->module~t_cell_collection_m module~output_m->module~input_m module~output_m->module~t_cell_collection_m module~t_cell_collection_m->module~distribution_m iso_c_binding iso_c_binding module~t_cell_collection_m->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Solve the partial differential equation governing unsteady 3D homogeneous, isotropic molecular diffusion\nusing 2nd-order-accurate central differences in space and 2nd-order Runge-Kutta time advancement. Calls program~~diffusion~~CallsGraph program~diffusion diffusion interface~define subdomain_t%define program~diffusion->interface~define interface~dt_stable subdomain_t%dt_stable program~diffusion->interface~dt_stable Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( subdomain_t ) :: phi type( subdomain_t ) :: phi_half integer, parameter :: steps = 1000 integer :: step real, parameter :: D = 1. real :: dt","tags":"","url":"program/diffusion.html"},{"title":"main – Matcha","text":"Uses matcha_m program~~main~~UsesGraph program~main main module~matcha_m matcha_m program~main->module~matcha_m module~distribution_m distribution_m module~matcha_m->module~distribution_m module~input_m input_m module~matcha_m->module~input_m module~output_m output_m module~matcha_m->module~output_m module~subdomain_m subdomain_m module~matcha_m->module~subdomain_m module~t_cell_collection_m t_cell_collection_m module~matcha_m->module~t_cell_collection_m module~output_m->module~input_m module~output_m->module~t_cell_collection_m module~t_cell_collection_m->module~distribution_m iso_c_binding iso_c_binding module~t_cell_collection_m->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Matcha: Motility Analysis of T-Cell Histories in Activation Calls program~~main~~CallsGraph program~main main interface~matcha matcha program~main->interface~matcha interface~my_num_cells output_t%my_num_cells program~main->interface~my_num_cells simulated_distribution simulated_distribution program~main->simulated_distribution Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( output_t ) :: output","tags":"","url":"program/main.html"},{"title":"input_m.f90 – Matcha","text":"Files dependent on this one sourcefile~~input_m.f90~~AfferentGraph sourcefile~input_m.f90 input_m.f90 sourcefile~input_s.f90 input_s.f90 sourcefile~input_s.f90->sourcefile~input_m.f90 sourcefile~matcha_m.f90 matcha_m.f90 sourcefile~matcha_m.f90->sourcefile~input_m.f90 sourcefile~output_m.f90 output_m.f90 sourcefile~matcha_m.f90->sourcefile~output_m.f90 sourcefile~output_m.f90->sourcefile~input_m.f90 sourcefile~diffusion.f90 diffusion.f90 sourcefile~diffusion.f90->sourcefile~matcha_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~matcha_m.f90 sourcefile~matcha_s.f90 matcha_s.F90 sourcefile~matcha_s.f90->sourcefile~matcha_m.f90 sourcefile~output_s.f90 output_s.f90 sourcefile~output_s.f90->sourcefile~output_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module input_m implicit none private public :: input_t type input_t private integer :: num_cells_ = 6000 , num_positions_ = 6000 , num_dimensions_ = 3 , num_intervals_ = 4 double precision :: time_step_ = 0.1D0 !double precision, allocatable :: sample_distribution_(:,:) !allocate(sample_distribution_(num_intervals_,2)) contains procedure :: num_cells procedure :: num_positions procedure :: num_dimensions procedure :: num_intervals procedure :: time_step procedure :: sample_distribution end type interface pure module function num_cells ( self ) result ( n ) implicit none class ( input_t ), intent ( in ) :: self integer n end function pure module function num_positions ( self ) result ( n ) implicit none class ( input_t ), intent ( in ) :: self integer n end function pure module function num_dimensions ( self ) result ( n ) implicit none class ( input_t ), intent ( in ) :: self integer n end function pure module function num_intervals ( self ) result ( n ) implicit none class ( input_t ), intent ( in ) :: self integer n end function pure module function time_step ( self ) result ( dt ) implicit none class ( input_t ), intent ( in ) :: self double precision dt end function time_step pure module function sample_distribution ( self ) result ( empirical_distribution ) implicit none class ( input_t ), intent ( in ) :: self double precision , allocatable :: empirical_distribution (:,:) end function sample_distribution end interface end module input_m","tags":"","url":"sourcefile/input_m.f90.html"},{"title":"matcha_m.f90 – Matcha","text":"This file depends on sourcefile~~matcha_m.f90~~EfferentGraph sourcefile~matcha_m.f90 matcha_m.f90 sourcefile~distribution_m.f90 distribution_m.f90 sourcefile~matcha_m.f90->sourcefile~distribution_m.f90 sourcefile~input_m.f90 input_m.f90 sourcefile~matcha_m.f90->sourcefile~input_m.f90 sourcefile~output_m.f90 output_m.f90 sourcefile~matcha_m.f90->sourcefile~output_m.f90 sourcefile~subdomain_m.f90 subdomain_m.f90 sourcefile~matcha_m.f90->sourcefile~subdomain_m.f90 sourcefile~t_cell_collection_m.f90 t_cell_collection_m.f90 sourcefile~matcha_m.f90->sourcefile~t_cell_collection_m.f90 sourcefile~output_m.f90->sourcefile~input_m.f90 sourcefile~output_m.f90->sourcefile~t_cell_collection_m.f90 sourcefile~t_cell_collection_m.f90->sourcefile~distribution_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~matcha_m.f90~~AfferentGraph sourcefile~matcha_m.f90 matcha_m.f90 sourcefile~diffusion.f90 diffusion.f90 sourcefile~diffusion.f90->sourcefile~matcha_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~matcha_m.f90 sourcefile~matcha_s.f90 matcha_s.F90 sourcefile~matcha_s.f90->sourcefile~matcha_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module matcha_m use t_cell_collection_m , only : t_cell_collection_t use distribution_m , only : distribution_t use input_m , only : input_t use output_m , only : output_t use subdomain_m , only : subdomain_t implicit none interface module function matcha ( input ) result ( history ) implicit none type ( input_t ), intent ( in ) :: input type ( t_cell_collection_t ), allocatable :: history (:) end function end interface end module","tags":"","url":"sourcefile/matcha_m.f90.html"},{"title":"subdomain_s.F90 – Matcha","text":"This file depends on sourcefile~~subdomain_s.f90~~EfferentGraph sourcefile~subdomain_s.f90 subdomain_s.F90 sourcefile~subdomain_m.f90 subdomain_m.f90 sourcefile~subdomain_s.f90->sourcefile~subdomain_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt #include \"assert_macros.h\" submodule ( subdomain_m ) subdomain_s use assert_m use julienne_m , only : bin_t implicit none real , allocatable :: halo_x (:,:,:)[:] integer , parameter :: west = 1 , east = 2 real dx_ , dy_ , dz_ integer my_nx , nx , ny , nz , me , num_subdomains , my_internal_west , my_internal_east real , allocatable :: increment (:,:,:) contains module procedure dt_stable !! Set the time step at 90% of the stability limit obtained generalizing to 3D the value provided for 2D by !! Kassinos, S., & Alexiadis, A. (2024). Beyond Language: Applying MLX Transformers to Engineering Physics. !! arXiv preprint arXiv:2410.04167. my_dt = 0.9 * ( 1. / ( 1. / dx_ ** 2 + 1. / dy_ ** 2 + 1. / dz_ ** 2 )) * ( 1. / ( 2. * alpha )) end procedure module procedure define integer , parameter :: nx_boundaries = 2 nx = n ny = nx nz = nx dx_ = side / ( nx - 1 ) dy_ = dx_ dz_ = dx_ call_assert ( num_subdomains <= nx - nx_boundaries ) me = this_image () num_subdomains = num_images () associate ( bin => bin_t ( num_items = nx , num_bins = num_subdomains , bin_number = me )) my_nx = bin % last () - bin % first () + 1 end associate if ( allocated ( self % s_ )) deallocate ( self % s_ ) allocate ( self % s_ ( my_nx , ny , nz )) my_internal_west = merge ( 2 , 1 , me == 1 ) my_internal_east = merge ( my_nx - 1 , my_nx , me == num_subdomains ) self % s_ ( my_internal_west : my_internal_east , 2 : ny - 1 , 2 : nz - 1 ) = internal_val ! internal points self % s_ (:, : , 1 ) = boundary_val ! minimum z boundary self % s_ (:, : , nz ) = boundary_val ! maximum z boundary self % s_ (:, 1 , : ) = boundary_val ! minimum y boundary self % s_ (:, ny , : ) = boundary_val ! maximum y boundary if ( me == 1 ) self % s_ ( 1 , :, :) = boundary_val ! minimum x boundary if ( me == num_subdomains ) self % s_ ( my_nx , :, :) = boundary_val ! maximum x boundary if ( allocated ( halo_x )) deallocate ( halo_x ) allocate ( halo_x ( west : east , ny , nz )[ * ]) if ( me > 1 ) halo_x ( east ,:,:)[ me - 1 ] = self % s_ ( 1 ,:,:) if ( me < num_subdomains ) halo_x ( west ,:,:)[ me + 1 ] = self % s_ ( my_nx ,:,:) sync all end procedure module procedure dx my_dx = dx_ end procedure module procedure dy my_dy = dy_ end procedure module procedure dz my_dz = dz_ end procedure module procedure laplacian integer i , j , k real , allocatable :: halo_west (:,:), halo_east (:,:) call_assert ( allocated ( rhs % s_ )) call_assert ( allocated ( halo_x )) allocate ( laplacian_rhs % s_ ( my_nx , ny , nz )) halo_west = merge ( halo_x ( west ,:,:), rhs % s_ ( 1 ,:,:), me /= 1 ) ! conditionally use halo value i = my_internal_west call_assert_describe ( i + 1 <= my_nx , \"laplacian: westernmost subdomain too small\" ) ! Compute Laplacians throughout the low-x boundary subdomain using non-allocatable associations: associate ( laplacian_phi => laplacian_rhs % s_ , inbox => halo_west , phi => rhs % s_ ) #if HAVE_2018_LOCALITY_SPECIFIERS do concurrent ( j = 2 : ny - 1 , k = 2 : nz - 1 ) & default ( none ) shared ( laplacian_phi , inbox , phi , dx_ , dy_ , dz_ , i ) !Fortran 2018 loacality specifiers #else do concurrent ( j = 2 : ny - 1 , k = 2 : nz - 1 ) #endif laplacian_phi ( i , j , k ) = ( inbox ( j , k ) - 2 * phi ( i , j , k ) + phi ( i + 1 , j , k )) / dx_ ** 2 + & ( phi ( i , j - 1 , k ) - 2 * phi ( i , j , k ) + phi ( i , j + 1 , k )) / dy_ ** 2 + & ( phi ( i , j , k - 1 ) - 2 * phi ( i , j , k ) + phi ( i , j , k + 1 )) / dz_ ** 2 end do end associate ! Compute Laplacians throughout non-boundary subdomains with non-allocatable associations: associate ( laplacian_phi => laplacian_rhs % s_ , phi => rhs % s_ ) #if HAVE_2018_LOCALITY_SPECIFIERS do concurrent ( i = my_internal_west + 1 : my_internal_east - 1 , j = 2 : ny - 1 , k = 2 : nz - 1 ) & default ( none ) shared ( laplacian_phi , phi , dx_ , dy_ , dz_ ) ! Fortran 2018 locality specifiers #else do concurrent ( i = my_internal_west + 1 : my_internal_east - 1 , j = 2 : ny - 1 , k = 2 : nz - 1 ) #endif laplacian_phi ( i , j , k ) = ( phi ( i - 1 , j , k ) - 2 * phi ( i , j , k ) + phi ( i + 1 , j , k )) / dx_ ** 2 + & ( phi ( i , j - 1 , k ) - 2 * phi ( i , j , k ) + phi ( i , j + 1 , k )) / dy_ ** 2 + & ( phi ( i , j , k - 1 ) - 2 * phi ( i , j , k ) + phi ( i , j , k + 1 )) / dz_ ** 2 end do end associate halo_east = merge ( halo_x ( east ,:,:), rhs % s_ ( my_nx ,:,:), me /= num_subdomains ) !conditionally use halo value i = my_internal_east call_assert_describe ( i - 1 > 0 , \"laplacian: easternmost subdomain too small\" ) ! Compute Laplacians throughout the high-x boundary subdomain using non-allocatable associations: associate ( laplacian_phi => laplacian_rhs % s_ , inbox => halo_east , phi => rhs % s_ ) #if HAVE_2018_LOCALITY_SPECIFIERS do concurrent ( j = 2 : ny - 1 , k = 2 : nz - 1 ) & ! compute Laplacian in low-x boundary subdomain default ( none ) shared ( laplacian_phi , inbox , phi , dx_ , dy_ , dz_ , i ) ! Fortran 2018 locality specifiers #else do concurrent ( j = 2 : ny - 1 , k = 2 : nz - 1 ) ! compute Laplacian in low-x boundary subdomain #endif laplacian_phi ( i , j , k ) = ( phi ( i - 1 , j , k ) - 2 * phi ( i , j , k ) + inbox ( j , k )) / dx_ ** 2 + & ( phi ( i , j - 1 , k ) - 2 * phi ( i , j , k ) + phi ( i , j + 1 , k )) / dy_ ** 2 + & ( phi ( i , j , k - 1 ) - 2 * phi ( i , j , k ) + phi ( i , j , k + 1 )) / dz_ ** 2 end do end associate laplacian_rhs % s_ (:, 1 ,:) = 0. ! low-y boundary laplacian_rhs % s_ (:, ny ,:) = 0. ! high-y boundary laplacian_rhs % s_ (:,:, 1 ) = 0. ! low-z boundary laplacian_rhs % s_ (:,:, nz ) = 0. ! high-z boundary if ( me == 1 ) laplacian_rhs % s_ ( 1 ,:,:) = 0. ! low-x boundary if ( me == num_subdomains ) laplacian_rhs % s_ ( my_nx ,:,:) = 0. ! high-x boundary end procedure laplacian module procedure multiply call_assert ( allocated ( rhs % s_ )) product % s_ = lhs * rhs % s_ end procedure module procedure add call_assert ( allocated ( rhs % s_ )) total % s_ = lhs % s_ + rhs % s_ end procedure module procedure assign_and_sync call_assert ( allocated ( rhs % s_ )) sync all lhs % s_ = rhs % s_ if ( me > 1 ) halo_x ( east ,:,:)[ me - 1 ] = rhs % s_ ( 1 ,:,:) if ( me < num_subdomains ) halo_x ( west ,:,:)[ me + 1 ] = rhs % s_ ( my_nx ,:,:) sync all end procedure module procedure values call_assert ( allocated ( self % s_ )) my_values = self % s_ end procedure module procedure step call_assert ( allocated ( self % s_ )) call_assert ( allocated ( halo_x )) call_assert_describe ( my_internal_west + 1 <= my_nx , \"laplacian: westernmost subdomain too small\" ) call_assert_describe ( my_internal_east - 1 > 0 , \"laplacian: easternmost subdomain too small\" ) if (. not . allocated ( increment )) allocate ( increment ( my_nx , ny , nz )) call internal_points ( increment ) call edge_points ( increment ) call apply_boundary_condition ( increment ) sync all self % s_ = self % s_ + increment sync all call exchange_halo ( self % s_ ) contains subroutine internal_points ( ds ) real , intent ( inout ) :: ds (:,:,:) integer i , j , k do concurrent ( i = my_internal_west + 1 : my_internal_east - 1 , j = 2 : ny - 1 , k = 2 : nz - 1 ) ds ( i , j , k ) = alpha_dt * ( & ( self % s_ ( i - 1 , j , k ) - 2 * self % s_ ( i , j , k ) + self % s_ ( i + 1 , j , k )) / dx_ ** 2 + & ( self % s_ ( i , j - 1 , k ) - 2 * self % s_ ( i , j , k ) + self % s_ ( i , j + 1 , k )) / dy_ ** 2 + & ( self % s_ ( i , j , k - 1 ) - 2 * self % s_ ( i , j , k ) + self % s_ ( i , j , k + 1 )) / dz_ ** 2 & ) end do end subroutine subroutine edge_points ( ds ) real , intent ( inout ) :: ds (:,:,:) real , allocatable :: halo_west (:,:), halo_east (:,:) integer i , j , k halo_west = merge ( halo_x ( west ,:,:), self % s_ ( 1 , :,:), me /= 1 ) halo_east = merge ( halo_x ( east ,:,:), self % s_ ( my_nx ,:,:), me /= num_subdomains ) i = my_internal_west do concurrent ( j = 2 : ny - 1 , k = 2 : nz - 1 ) ds ( i , j , k ) = alpha_dt * ( & ( halo_west ( j , k ) - 2 * self % s_ ( i , j , k ) + self % s_ ( i + 1 , j , k )) / dx_ ** 2 + & ( self % s_ ( i , j - 1 , k ) - 2 * self % s_ ( i , j , k ) + self % s_ ( i , j + 1 , k )) / dy_ ** 2 + & ( self % s_ ( i , j , k - 1 ) - 2 * self % s_ ( i , j , k ) + self % s_ ( i , j , k + 1 )) / dz_ ** 2 & ) end do i = my_internal_east do concurrent ( j = 2 : ny - 1 , k = 2 : nz - 1 ) ds ( i , j , k ) = alpha_dt * ( & ( self % s_ ( i - 1 , j , k ) - 2 * self % s_ ( i , j , k ) + halo_east ( j , k )) / dx_ ** 2 + & ( self % s_ ( i , j - 1 , k ) - 2 * self % s_ ( i , j , k ) + self % s_ ( i , j + 1 , k )) / dy_ ** 2 + & ( self % s_ ( i , j , k - 1 ) - 2 * self % s_ ( i , j , k ) + self % s_ ( i , j , k + 1 )) / dz_ ** 2 & ) end do end subroutine subroutine apply_boundary_condition ( ds ) real , intent ( inout ) :: ds (:,:,:) integer i , j ds (:, 1 : ny : ny - 1 , : ) = 0. ds (:, : , 1 : nz : nz - 1 ) = 0. if ( me == 1 ) ds ( 1 ,:,:) = 0. if ( me == num_subdomains ) ds ( my_nx ,:,:) = 0. end subroutine subroutine exchange_halo ( s ) real , intent ( in ) :: s (:,:,:) if ( me > 1 ) halo_x ( east ,:,:)[ me - 1 ] = s ( 1 ,:,:) if ( me < num_subdomains ) halo_x ( west ,:,:)[ me + 1 ] = s ( my_nx ,:,:) end subroutine end procedure end submodule subdomain_s","tags":"","url":"sourcefile/subdomain_s.f90.html"},{"title":"t_cell_collection_m.f90 – Matcha","text":"This file depends on sourcefile~~t_cell_collection_m.f90~~EfferentGraph sourcefile~t_cell_collection_m.f90 t_cell_collection_m.f90 sourcefile~distribution_m.f90 distribution_m.f90 sourcefile~t_cell_collection_m.f90->sourcefile~distribution_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~t_cell_collection_m.f90~~AfferentGraph sourcefile~t_cell_collection_m.f90 t_cell_collection_m.f90 sourcefile~matcha_m.f90 matcha_m.f90 sourcefile~matcha_m.f90->sourcefile~t_cell_collection_m.f90 sourcefile~output_m.f90 output_m.f90 sourcefile~matcha_m.f90->sourcefile~output_m.f90 sourcefile~matcha_s.f90 matcha_s.F90 sourcefile~matcha_s.f90->sourcefile~t_cell_collection_m.f90 sourcefile~matcha_s.f90->sourcefile~matcha_m.f90 sourcefile~output_m.f90->sourcefile~t_cell_collection_m.f90 sourcefile~t_cell_collection_s.f90 t_cell_collection_s.F90 sourcefile~t_cell_collection_s.f90->sourcefile~t_cell_collection_m.f90 sourcefile~diffusion.f90 diffusion.f90 sourcefile~diffusion.f90->sourcefile~matcha_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~matcha_m.f90 sourcefile~output_s.f90 output_s.f90 sourcefile~output_s.f90->sourcefile~output_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module t_cell_collection_m !! Define a T-cell abstraction for motility simulations use distribution_m , only : distribution_t use iso_c_binding , only : c_ptr , c_double , c_int implicit none private public :: t_cell_collection_t public :: t_cell_collection_bind_C_t type t_cell_collection_t !! Encapsulate the state of a collection of T cells private double precision , allocatable :: positions_ (:,:) !! position vectors double precision time_ !! time stamp contains procedure :: positions procedure :: time end type integer , parameter :: positions_dimension = 2 type , bind ( C ) :: t_cell_collection_bind_C_t type ( c_ptr ) positions_ptr integer ( c_int ) positions_shape ( positions_dimension ) real ( c_double ) time end type interface t_cell_collection_t pure module function construct ( positions , time ) result ( t_cell_collection ) !! Return a t_cell_collection_t object with rescaled position vectors and the provided time stamp implicit none double precision , intent ( in ) :: positions (:,:), time type ( t_cell_collection_t ) t_cell_collection end function end interface interface t_cell_collection_bind_C_t elemental module function construct_bind_C ( t_cell_collection ) result ( t_cell_collection_bind_C ) !! Result is bind(C) representation of the data inside a t_cell_collection_t object implicit none type ( t_cell_collection_t ), intent ( in ), target :: t_cell_collection type ( t_cell_collection_bind_C_t ) t_cell_collection_bind_C end function end interface interface pure module function positions ( self ) result ( my_positions ) !! Return the t_cell_collection_t object's position vectors implicit none class ( t_cell_collection_t ), intent ( in ) :: self double precision , allocatable :: my_positions (:,:) end function elemental module function time ( self ) result ( my_time ) !! Return the t_cell_collection_t object's time stamp implicit none class ( t_cell_collection_t ), intent ( in ) :: self double precision my_time end function end interface end module t_cell_collection_m","tags":"","url":"sourcefile/t_cell_collection_m.f90.html"},{"title":"subdomain_m.f90 – Matcha","text":"Files dependent on this one sourcefile~~subdomain_m.f90~~AfferentGraph sourcefile~subdomain_m.f90 subdomain_m.f90 sourcefile~matcha_m.f90 matcha_m.f90 sourcefile~matcha_m.f90->sourcefile~subdomain_m.f90 sourcefile~subdomain_s.f90 subdomain_s.F90 sourcefile~subdomain_s.f90->sourcefile~subdomain_m.f90 sourcefile~diffusion.f90 diffusion.f90 sourcefile~diffusion.f90->sourcefile~matcha_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~matcha_m.f90 sourcefile~matcha_s.f90 matcha_s.F90 sourcefile~matcha_s.f90->sourcefile~matcha_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module subdomain_m implicit none private public :: subdomain_t type subdomain_t private real , allocatable :: s_ (:,:,:) contains procedure , pass ( self ) :: define procedure , pass ( self ) :: step procedure , pass ( rhs ) :: multiply generic :: operator (. laplacian .) => laplacian generic :: operator ( * ) => multiply generic :: operator ( + ) => add generic :: assignment ( = ) => assign_and_sync procedure dt_stable procedure dx procedure dy procedure dz procedure values procedure , private :: laplacian procedure , private :: add procedure , private :: assign_and_sync end type interface module subroutine define ( side , boundary_val , internal_val , n , self ) implicit none real , intent ( in ) :: side , boundary_val , internal_val integer , intent ( in ) :: n !! number of grid points in each coordinate direction class ( subdomain_t ), intent ( out ) :: self end subroutine module subroutine step ( alpha_dt , self ) implicit none real , intent ( in ) :: alpha_dt class ( subdomain_t ), intent ( inout ) :: self end subroutine pure module function values ( self ) result ( my_values ) implicit none class ( subdomain_t ), intent ( in ) :: self real , allocatable :: my_values (:,:,:) end function pure module function dx ( self ) result ( my_dx ) implicit none class ( subdomain_t ), intent ( in ) :: self real my_dx end function pure module function dy ( self ) result ( my_dy ) implicit none class ( subdomain_t ), intent ( in ) :: self real my_dy end function pure module function dz ( self ) result ( my_dz ) implicit none class ( subdomain_t ), intent ( in ) :: self real my_dz end function pure module function dt_stable ( self , alpha ) result ( my_dt ) !! Set the time step at 90% of the stability limit obtained generalizing to 3D the value provided for 2D by !! Kassinos, S., & Alexiadis, A. (2024). Beyond Language: Applying MLX Transformers to Engineering Physics. !! arXiv preprint arXiv:2410.04167. implicit none class ( subdomain_t ), intent ( in ) :: self real , intent ( in ) :: alpha real my_dt end function pure module function laplacian ( rhs ) result ( laplacian_rhs ) implicit none class ( subdomain_t ), intent ( in ) :: rhs type ( subdomain_t ) laplacian_rhs end function pure module function multiply ( lhs , rhs ) result ( product ) implicit none class ( subdomain_t ), intent ( in ) :: rhs real , intent ( in ) :: lhs type ( subdomain_t ) product end function pure module function add ( lhs , rhs ) result ( total ) implicit none class ( subdomain_t ), intent ( in ) :: lhs type ( subdomain_t ), intent ( in ) :: rhs type ( subdomain_t ) total end function module subroutine assign_and_sync ( lhs , rhs ) implicit none class ( subdomain_t ), intent ( out ) :: lhs type ( subdomain_t ), intent ( in ) :: rhs end subroutine end interface end module","tags":"","url":"sourcefile/subdomain_m.f90.html"},{"title":"distribution_s.F90 – Matcha","text":"This file depends on sourcefile~~distribution_s.f90~~EfferentGraph sourcefile~distribution_s.f90 distribution_s.F90 sourcefile~distribution_m.f90 distribution_m.f90 sourcefile~distribution_s.f90->sourcefile~distribution_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.tx #include \"assert_macros.h\" submodule ( distribution_m ) distribution_s use assert_m implicit none contains pure function monotonically_increasing ( f ) result ( monotonic ) double precision , intent ( in ) :: f (:) logical monotonic integer i monotonic = all ([( f ( i + 1 ) >= f ( i ), i = 1 , size ( f ) - 1 )]) end function module procedure construct integer i call_assert ( all ( sample_distribution (:, 2 ) >= 0.D0 )) associate ( nintervals => size ( sample_distribution , 1 )) distribution % vel_ = [( sample_distribution ( i , 1 ), i = 1 , nintervals )] ! Assign speeds to each distribution bin distribution % cumulative_distribution_ = [ 0.D0 , [( sum ( sample_distribution ( 1 : i , 2 )), i = 1 , nintervals )]] end associate call_assert ( monotonically_increasing ( distribution % cumulative_distribution_ )) end procedure construct module procedure cumulative_distribution call_assert ( allocated ( self % cumulative_distribution_ )) my_cumulative_distribution = self % cumulative_distribution_ end procedure module procedure velocities double precision , allocatable :: sampled_speeds (:,:), dir (:,:,:) integer cell , step , k call_assert ( allocated ( self % cumulative_distribution_ )) call_assert ( allocated ( self % vel_ )) ! Sample from the distribution associate ( ncells => size ( speeds , 1 ), nsteps => size ( speeds , 2 )) allocate ( sampled_speeds ( ncells , nsteps )) do concurrent ( cell = 1 : ncells , step = 1 : nsteps ) k = findloc ( speeds ( cell , step ) >= self % cumulative_distribution (), value = . false ., dim = 1 ) - 1 sampled_speeds ( cell , step ) = self % vel_ ( k ) end do ! Create unit vectors dir = directions (:, 1 : nsteps ,:) associate ( dir_mag => sqrt ( dir (:,:, 1 ) ** 2 + dir (:,:, 2 ) ** 2 + dir (:,:, 3 ) ** 2 )) associate ( dir_mag_ => merge ( dir_mag , epsilon ( dir_mag ), dir_mag /= 0. )) dir (:,:, 1 ) = dir (:,:, 1 ) / dir_mag_ dir (:,:, 2 ) = dir (:,:, 2 ) / dir_mag_ dir (:,:, 3 ) = dir (:,:, 3 ) / dir_mag_ end associate end associate allocate ( my_velocities , mold = dir ) do concurrent ( step = 1 : nsteps ) my_velocities (:, step , 1 ) = sampled_speeds (:, step ) * dir (:, step , 1 ) my_velocities (:, step , 2 ) = sampled_speeds (:, step ) * dir (:, step , 2 ) my_velocities (:, step , 3 ) = sampled_speeds (:, step ) * dir (:, step , 3 ) end do end associate end procedure end submodule distribution_s","tags":"","url":"sourcefile/distribution_s.f90.html"},{"title":"distribution_m.f90 – Matcha","text":"Files dependent on this one sourcefile~~distribution_m.f90~~AfferentGraph sourcefile~distribution_m.f90 distribution_m.f90 sourcefile~distribution_s.f90 distribution_s.F90 sourcefile~distribution_s.f90->sourcefile~distribution_m.f90 sourcefile~matcha_m.f90 matcha_m.f90 sourcefile~matcha_m.f90->sourcefile~distribution_m.f90 sourcefile~t_cell_collection_m.f90 t_cell_collection_m.f90 sourcefile~matcha_m.f90->sourcefile~t_cell_collection_m.f90 sourcefile~output_m.f90 output_m.f90 sourcefile~matcha_m.f90->sourcefile~output_m.f90 sourcefile~matcha_s.f90 matcha_s.F90 sourcefile~matcha_s.f90->sourcefile~distribution_m.f90 sourcefile~matcha_s.f90->sourcefile~matcha_m.f90 sourcefile~matcha_s.f90->sourcefile~t_cell_collection_m.f90 sourcefile~t_cell_collection_m.f90->sourcefile~distribution_m.f90 sourcefile~diffusion.f90 diffusion.f90 sourcefile~diffusion.f90->sourcefile~matcha_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~matcha_m.f90 sourcefile~output_m.f90->sourcefile~t_cell_collection_m.f90 sourcefile~t_cell_collection_s.f90 t_cell_collection_s.F90 sourcefile~t_cell_collection_s.f90->sourcefile~t_cell_collection_m.f90 sourcefile~output_s.f90 output_s.f90 sourcefile~output_s.f90->sourcefile~output_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module distribution_m implicit none private public :: distribution_t type distribution_t private double precision , allocatable , dimension (:) :: vel_ , cumulative_distribution_ contains procedure :: cumulative_distribution procedure :: velocities end type interface distribution_t pure module function construct ( sample_distribution ) result ( distribution ) implicit none double precision , intent ( in ) :: sample_distribution (:,:) type ( distribution_t ) distribution end function end interface interface pure module function cumulative_distribution ( self ) result ( my_cumulative_distribution ) implicit none class ( distribution_t ), intent ( in ) :: self double precision , allocatable :: my_cumulative_distribution (:) end function pure module function velocities ( self , speeds , directions ) result ( my_velocities ) !! Return the t_cell_collection_t object's velocity vectors implicit none class ( distribution_t ), intent ( in ) :: self double precision , intent ( in ) :: speeds (:,:), directions (:,:,:) double precision , allocatable :: my_velocities (:,:,:) end function velocities end interface end module distribution_m","tags":"","url":"sourcefile/distribution_m.f90.html"},{"title":"diffusion.f90 – Matcha","text":"This file depends on sourcefile~~diffusion.f90~~EfferentGraph sourcefile~diffusion.f90 diffusion.f90 sourcefile~matcha_m.f90 matcha_m.f90 sourcefile~diffusion.f90->sourcefile~matcha_m.f90 sourcefile~distribution_m.f90 distribution_m.f90 sourcefile~matcha_m.f90->sourcefile~distribution_m.f90 sourcefile~input_m.f90 input_m.f90 sourcefile~matcha_m.f90->sourcefile~input_m.f90 sourcefile~output_m.f90 output_m.f90 sourcefile~matcha_m.f90->sourcefile~output_m.f90 sourcefile~subdomain_m.f90 subdomain_m.f90 sourcefile~matcha_m.f90->sourcefile~subdomain_m.f90 sourcefile~t_cell_collection_m.f90 t_cell_collection_m.f90 sourcefile~matcha_m.f90->sourcefile~t_cell_collection_m.f90 sourcefile~output_m.f90->sourcefile~input_m.f90 sourcefile~output_m.f90->sourcefile~t_cell_collection_m.f90 sourcefile~t_cell_collection_m.f90->sourcefile~distribution_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program diffusion !! Solve the partial differential equation governing unsteady 3D homogeneous, isotropic molecular diffusion !! using 2nd-order-accurate central differences in space and 2nd-order Runge-Kutta time advancement. use matcha_m , only : subdomain_t implicit none type ( subdomain_t ) phi , phi_half integer , parameter :: steps = 1000 integer step real , parameter :: D = 1. real dt call phi % define ( side = 1. , boundary_val = 0. , internal_val = 1. , n = 11 ) ! const. internally with a step down at boundaries associate ( dt => phi % dt_stable ( D )) do step = 1 , steps phi_half = phi + ( dt / 2. ) * D * . laplacian . phi phi = phi + dt * D * . laplacian . phi_half end do end associate end program","tags":"","url":"sourcefile/diffusion.f90.html"},{"title":"output_m.f90 – Matcha","text":"This file depends on sourcefile~~output_m.f90~~EfferentGraph sourcefile~output_m.f90 output_m.f90 sourcefile~input_m.f90 input_m.f90 sourcefile~output_m.f90->sourcefile~input_m.f90 sourcefile~t_cell_collection_m.f90 t_cell_collection_m.f90 sourcefile~output_m.f90->sourcefile~t_cell_collection_m.f90 sourcefile~distribution_m.f90 distribution_m.f90 sourcefile~t_cell_collection_m.f90->sourcefile~distribution_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~output_m.f90~~AfferentGraph sourcefile~output_m.f90 output_m.f90 sourcefile~matcha_m.f90 matcha_m.f90 sourcefile~matcha_m.f90->sourcefile~output_m.f90 sourcefile~output_s.f90 output_s.f90 sourcefile~output_s.f90->sourcefile~output_m.f90 sourcefile~diffusion.f90 diffusion.f90 sourcefile~diffusion.f90->sourcefile~matcha_m.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~matcha_m.f90 sourcefile~matcha_s.f90 matcha_s.F90 sourcefile~matcha_s.f90->sourcefile~matcha_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module output_m !! Output data abstraction use input_m , only : input_t use t_cell_collection_m , only : t_cell_collection_t implicit none private public :: output_t type output_t !! Encapsulate an input/result pair private type ( input_t ) input_ type ( t_cell_collection_t ), allocatable :: history_ (:) contains procedure :: simulated_distribution procedure :: my_num_cells end type interface output_t pure module function construct ( input , history ) result ( output ) !! Construct a new output_t object implicit none type ( input_t ), intent ( in ) :: input type ( t_cell_collection_t ), intent ( in ) :: history (:) type ( output_t ) :: output end function end interface interface pure module function simulated_distribution ( self ) result ( output_distribution ) !! The result is a histogram calculated from the simulation output implicit none class ( output_t ), intent ( in ) :: self double precision , allocatable :: output_distribution (:,:) end function pure module function my_num_cells ( self ) result ( num_cells ) implicit none class ( output_t ), intent ( in ) :: self integer num_cells end function end interface end module output_m","tags":"","url":"sourcefile/output_m.f90.html"},{"title":"t_cell_collection_s.F90 – Matcha","text":"This file depends on sourcefile~~t_cell_collection_s.f90~~EfferentGraph sourcefile~t_cell_collection_s.f90 t_cell_collection_s.F90 sourcefile~t_cell_collection_m.f90 t_cell_collection_m.f90 sourcefile~t_cell_collection_s.f90->sourcefile~t_cell_collection_m.f90 sourcefile~distribution_m.f90 distribution_m.f90 sourcefile~t_cell_collection_m.f90->sourcefile~distribution_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt #include \"assert_macros.h\" submodule ( t_cell_collection_m ) t_cell_collection_s use assert_m use iso_c_binding , only : c_loc use assert_m , only : assert implicit none contains module procedure construct t_cell_collection % positions_ = positions t_cell_collection % time_ = time end procedure module procedure positions call_assert ( allocated ( self % positions_ )) my_positions = self % positions_ end procedure module procedure time my_time = self % time_ end procedure module procedure construct_bind_C t_cell_collection_bind_C % positions_ptr = c_loc ( t_cell_collection % positions_ ) t_cell_collection_bind_C % positions_shape = shape ( t_cell_collection % positions_ ) t_cell_collection_bind_C % time = t_cell_collection % time_ end procedure end submodule t_cell_collection_s","tags":"","url":"sourcefile/t_cell_collection_s.f90.html"},{"title":"main.f90 – Matcha","text":"This file depends on sourcefile~~main.f90~~EfferentGraph sourcefile~main.f90 main.f90 sourcefile~matcha_m.f90 matcha_m.f90 sourcefile~main.f90->sourcefile~matcha_m.f90 sourcefile~distribution_m.f90 distribution_m.f90 sourcefile~matcha_m.f90->sourcefile~distribution_m.f90 sourcefile~input_m.f90 input_m.f90 sourcefile~matcha_m.f90->sourcefile~input_m.f90 sourcefile~output_m.f90 output_m.f90 sourcefile~matcha_m.f90->sourcefile~output_m.f90 sourcefile~subdomain_m.f90 subdomain_m.f90 sourcefile~matcha_m.f90->sourcefile~subdomain_m.f90 sourcefile~t_cell_collection_m.f90 t_cell_collection_m.f90 sourcefile~matcha_m.f90->sourcefile~t_cell_collection_m.f90 sourcefile~output_m.f90->sourcefile~input_m.f90 sourcefile~output_m.f90->sourcefile~t_cell_collection_m.f90 sourcefile~t_cell_collection_m.f90->sourcefile~distribution_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program main !! Matcha: Motility Analysis of T-Cell Histories in Activation use matcha_m , only : matcha , input_t , output_t implicit none type ( output_t ) output associate ( input => input_t ()) output = output_t ( input , matcha ( input )) block double precision , allocatable :: simulated_distribution (:,:) integer , parameter :: freq = 2 integer num_cells num_cells = output % my_num_cells () simulated_distribution = output % simulated_distribution () simulated_distribution (:, freq ) = num_cells * simulated_distribution (:, freq ) call co_sum ( simulated_distribution (:, freq ), result_image = 1 ) call co_sum ( num_cells , result_image = 1 ) if ( this_image () == 1 ) simulated_distribution (:, freq ) = simulated_distribution (:, freq ) / dble ( num_cells ) end block end associate print * print * , \"----> Matcha done. <----\" end program","tags":"","url":"sourcefile/main.f90.html"},{"title":"input_s.f90 – Matcha","text":"This file depends on sourcefile~~input_s.f90~~EfferentGraph sourcefile~input_s.f90 input_s.f90 sourcefile~input_m.f90 input_m.f90 sourcefile~input_s.f90->sourcefile~input_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( input_m ) input_s implicit none contains module procedure num_cells n = self % num_cells_ end procedure module procedure num_positions n = self % num_positions_ end procedure module procedure num_dimensions n = self % num_dimensions_ end procedure module procedure num_intervals n = self % num_intervals_ end procedure module procedure time_step dt = self % time_step_ end procedure module procedure sample_distribution integer i , nintervals double precision speed_lower , speed_upper double precision range , pi , dspeed , sumy double precision speed_lower_bin double precision speed_upper_bin double precision speed_middle_bin double precision , allocatable :: speeds (:), probability (:) nintervals = self % num_intervals_ speed_lower = 0.d0 speed_upper = 6.d0 range = speed_upper - speed_lower pi = acos ( - 1.d0 ) dspeed = range / dble ( nintervals ) allocate ( speeds ( nintervals ), probability ( nintervals )) !    Create normal distribution sumy = 0.d0 do i = 1 , nintervals speed_lower_bin = speed_lower + dble ( i - 1 ) * dspeed speed_upper_bin = speed_lower + dble ( i ) * dspeed speed_middle_bin = 0.5d0 * ( speed_lower_bin + speed_upper_bin ) speeds ( i ) = speed_middle_bin probability ( i ) = exp ( - ( speeds ( i ) - 3.d0 ) ** 2 / 2.d0 ) / dsqrt ( 2.d0 * pi ) ! Use normal distribution sumy = sumy + probability ( i ) end do do i = 1 , nintervals probability ( i ) = probability ( i ) / sumy end do allocate ( empirical_distribution ( nintervals , 2 )) do i = 1 , nintervals empirical_distribution ( i , 1 ) = speeds ( i ) empirical_distribution ( i , 2 ) = probability ( i ) end do end procedure end submodule input_s","tags":"","url":"sourcefile/input_s.f90.html"},{"title":"output_s.f90 – Matcha","text":"This file depends on sourcefile~~output_s.f90~~EfferentGraph sourcefile~output_s.f90 output_s.f90 sourcefile~output_m.f90 output_m.f90 sourcefile~output_s.f90->sourcefile~output_m.f90 sourcefile~input_m.f90 input_m.f90 sourcefile~output_m.f90->sourcefile~input_m.f90 sourcefile~t_cell_collection_m.f90 t_cell_collection_m.f90 sourcefile~output_m.f90->sourcefile~t_cell_collection_m.f90 sourcefile~distribution_m.f90 distribution_m.f90 sourcefile~t_cell_collection_m.f90->sourcefile~distribution_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( output_m ) output_s implicit none contains module procedure construct output % input_ = input output % history_ = history end procedure module procedure my_num_cells num_cells = size ( self % history_ ( 1 )% positions (), 1 ) end procedure module procedure simulated_distribution integer i integer , allocatable :: k (:) double precision , allocatable :: vel (:) integer , parameter :: speed = 1 , freq = 2 ! subscripts for speeds and frequencies associate ( speeds => sim_speeds ( self % history_ )) associate ( emp_distribution => self % input_ % sample_distribution ()) associate ( nintervals => size ( emp_distribution (:, 1 ))) allocate ( output_distribution ( nintervals , 2 )) output_distribution (:, freq ) = 0.d0 output_distribution (:, speed ) = emp_distribution (:, speed ) associate ( dvel_half => ( emp_distribution ( 2 , speed ) - emp_distribution ( 1 , speed )) / 2.d0 ) vel = [ emp_distribution ( 1 , speed ) - dvel_half , [( emp_distribution ( i , speed ) + dvel_half , i = 1 , nintervals )]] associate ( nspeeds => size ( speeds )) allocate ( k ( nspeeds )) do concurrent ( i = 1 : nspeeds ) k ( i ) = findloc ( speeds ( i ) >= vel , value = . false ., dim = 1 ) - 1 end do end associate do concurrent ( i = 1 : size ( output_distribution , 1 )) output_distribution ( i , freq ) = count ( k == i ) end do output_distribution (:, freq ) = output_distribution (:, freq ) / sum ( output_distribution (:, freq )) end associate end associate end associate end associate contains pure function sim_speeds ( history ) result ( speeds ) type ( t_cell_collection_t ), intent ( in ) :: history (:) double precision , allocatable :: speeds (:) integer , parameter :: nspacedims = 3 integer i , j , k , ij double precision , allocatable :: x (:,:,:), t (:), u (:) associate ( & npositions => size ( history , 1 ), & ncells => size ( history ( 1 )% positions (), 1 ) & ) allocate ( x ( npositions , ncells , nspacedims )) do concurrent ( i = 1 : npositions ) x ( i ,:,:) = history ( i )% positions () end do t = history % time () allocate ( speeds ( ncells * ( npositions - 1 ))) do concurrent ( i = 1 : npositions - 1 , j = 1 : ncells ) u = ( x ( i + 1 , j ,:) - x ( i , j ,:)) / ( t ( i + 1 ) - t ( i )) ij = i + ( j - 1 ) * ( npositions - 1 ) speeds ( ij ) = sqrt ( sum ([( u ( k ) ** 2 , k = 1 , nspacedims )])) end do end associate end function end procedure end submodule output_s","tags":"","url":"sourcefile/output_s.f90.html"},{"title":"matcha_s.F90 – Matcha","text":"This file depends on sourcefile~~matcha_s.f90~~EfferentGraph sourcefile~matcha_s.f90 matcha_s.F90 sourcefile~distribution_m.f90 distribution_m.f90 sourcefile~matcha_s.f90->sourcefile~distribution_m.f90 sourcefile~matcha_m.f90 matcha_m.f90 sourcefile~matcha_s.f90->sourcefile~matcha_m.f90 sourcefile~t_cell_collection_m.f90 t_cell_collection_m.f90 sourcefile~matcha_s.f90->sourcefile~t_cell_collection_m.f90 sourcefile~matcha_m.f90->sourcefile~distribution_m.f90 sourcefile~matcha_m.f90->sourcefile~t_cell_collection_m.f90 sourcefile~input_m.f90 input_m.f90 sourcefile~matcha_m.f90->sourcefile~input_m.f90 sourcefile~output_m.f90 output_m.f90 sourcefile~matcha_m.f90->sourcefile~output_m.f90 sourcefile~subdomain_m.f90 subdomain_m.f90 sourcefile~matcha_m.f90->sourcefile~subdomain_m.f90 sourcefile~t_cell_collection_m.f90->sourcefile~distribution_m.f90 sourcefile~output_m.f90->sourcefile~t_cell_collection_m.f90 sourcefile~output_m.f90->sourcefile~input_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( matcha_m ) matcha_s use t_cell_collection_m , only : t_cell_collection_t use distribution_m , only : distribution_t use julienne_m , only : bin_t implicit none contains module procedure matcha associate ( & ncells => input % num_cells (), & npositions => input % num_positions (), & ndim => input % num_dimensions (), & nintervals => input % num_intervals (), & dt => input % time_step (), & empirical_distribution => input % sample_distribution () & ) block double precision , parameter :: scale = 10 0.D0 double precision , allocatable :: random_positions (:,:), random_4vectors (:,:,:) type ( distribution_t ) distribution integer , parameter :: nveldim = 4 integer step associate ( me => this_image ()) associate ( bin => bin_t ( num_items = ncells , num_bins = num_images (), bin_number = me )) associate ( my_num_cells => bin % last () - bin % first () + 1 ) call random_init ( repeatable = . true ., image_distinct = . true .) allocate ( random_positions ( my_num_cells , ndim )) call random_number ( random_positions ) associate ( nsteps => npositions - 1 ) allocate ( random_4vectors ( my_num_cells , nsteps , nveldim )) call random_number ( random_4vectors ) distribution = distribution_t ( empirical_distribution ) associate ( random_speeds => random_4vectors (:,:, 1 ), random_directions => random_4vectors (:,:, 2 : 4 )) associate ( v => distribution % velocities ( random_speeds , random_directions )) allocate ( history ( nsteps )) history ( 1 ) = t_cell_collection_t ( scale * random_positions , time = 0.D0 ) do step = 2 , nsteps associate ( x => history ( step - 1 )% positions (), t => history ( step - 1 )% time ()) history ( step ) = t_cell_collection_t ( x + v (:, step - 1 ,:) * dt , t + dt ) end associate end do end associate end associate end associate end associate end associate end associate end block end associate end procedure end submodule matcha_s","tags":"","url":"sourcefile/matcha_s.f90.html"}]}