A Parallel 2D Unsteady Heat Equation Solver
===========================================

This subdirectory's [heat-equation.f90] file contains a parallel solver for the
unsteady 2D heat equation written in Fortran 2018.  The numerical algorithm uses
2nd-order-accurate central finite differencing in space and 1st-order-accurate
explicit Euler advancement in time.

Downloading, Building, and Running
----------------------------------
### Prerequisites
* The [GCC] Fortran compiler (`gfortran`)
* The [OpenCoarrays] compiler wrapper (`caf`) and program launcher (`cafrun`)
* The [Fortran Package Manager] (`fpm`)

### Parallel execution with GCC and OpenCoarrays
With the [GCC](https://gcc.gnu.org) Fortran compiler (`gfortran`) and the
[OpenCoarrays] parallel runtime library installed,
```
git clone https://github.com/BerkeleyLab/matcha
cd matcha
fpm run --example heat-equation --compiler caf --runner "cafrun -n 2"
```
where you can replace `2` in the above line with the desired number of 
images 

### Parallel execution with the Intel `ifx` compiler
With the Intel `ifx` Fortran compiler installed, replace the above
`fpm` command with
```
export FOR_COARRAY_NUM_IMAGES=2
fpm run --example heat-equation --compiler ifx --flag "-coarray"
```

### Serial execution with `gfortran` *without* requiring OpenCoarrays
With `gfortran` installed, replace the above `fpm` commands with
```
fpm run --example heat-equation
```

Exercise
--------
In addition to demonstrating parallel features of Fortran 2018, this example
shows an object-oriented, functional programming style based on Fortran's
user-defined operators such as the `.laplacian.` operator defined in this
example.  To demonstrate the expressive power and flexibility of this
approach, try modifying the modifying the main program to use 2nd-order
Runge-Kutta time advancement:
```
T_half = T + 0.5*dt*alpha* .laplacian. T
T = T + dt*alpha* .laplacian. T_half
```
You'll need to append `, T_half` to the declaration `type(subdomain_2D_t) T`.
With some care, you could modify the main program to use any desired order of
Runge-Kutta algorithm without changing any of the supporting code.

This example also demonstrates a beneif of Fortran's facility for declaring a
procedure to be `pure`: the semantics of `pure` procedures essentially
guarantees that the above right-hand-side expressions can be evaluated fully
asynchronously across all images.  No operator can modify state that would be
observable by another operator other than via the first operator's result. This
would be true even if an operator executing on one image performs communication
to _get_ data from another image via a coarray.  To reduce communication waiting
times, however, each image in our example proactively _puts_ data onto
neighboring images.  Puts generally outperofrm gets because the data can be
shipped off as soon the data are ready.  All image control (synchronization in
this example) happens in the user-defined assignment.  Our assignment modifies
state that is observable by other images: halo values.  Modifying existing state
is outside the functional programming pattern so the assignment is a natural
place for synchronization or other forms of image control.

[heat-equation.f90]: ./heat-equation.f90
[GCC]: https://gcc.gnu.org
[OpenCoarrays]: https://github.com/sourceryinstitute/opencoarrays
[Fortran Package Manager]: https://github.com/fortran-lang/fpm
